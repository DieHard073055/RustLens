[
  {
    "id": "expert-001",
    "category": "traits_generics",
    "difficulty": 5,
    "type": "spot_error",
    "code": "trait MyTrait {\n    fn method(&self) -> impl Iterator<Item = i32>;\n}",
    "question": "Is this valid Rust?",
    "options": [
      "Yes in Rust 2021+ with RPITIT (return position impl trait in traits)",
      "No - can't use impl Trait in traits",
      "No - must use Box<dyn Iterator>",
      "Only with #[feature] gate"
    ],
    "correct": 0,
    "explanation": "Rust 1.75+ supports RPITIT, allowing impl Trait in trait method return types without boxing.",
    "rust_book_link": "https://blog.rust-lang.org/2023/12/21/async-fn-rpit-in-traits.html"
  },
  {
    "id": "expert-002",
    "category": "lifetimes",
    "difficulty": 5,
    "type": "fix_code",
    "code": "struct Parser<'a> {\n    data: &'a str,\n}\n\nimpl<'a> Parser<'a> {\n    fn parse(&self) -> Result<&str, Error> {\n        // parsing logic\n    }\n}",
    "question": "What's the lifetime issue in parse?",
    "options": [
      "Return type needs &'a str - tied to struct lifetime",
      "Need &'self str",
      "Result can't contain references",
      "Nothing wrong"
    ],
    "correct": 0,
    "explanation": "The returned &str should live as long as the Parser's data. Use &'a str to tie it to the struct's lifetime.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html"
  },
  {
    "id": "expert-003",
    "category": "unsafe",
    "difficulty": 5,
    "type": "will_compile",
    "code": "use std::mem::ManuallyDrop;\n\nfn main() {\n    let x = ManuallyDrop::new(String::from(\"hello\"));\n    // x is never dropped\n}",
    "question": "What's the purpose of ManuallyDrop?",
    "options": [
      "Prevents automatic drop, useful for FFI and manual memory management",
      "Required for all heap allocations",
      "Makes types Copy",
      "Only for unsafe code"
    ],
    "correct": 0,
    "explanation": "ManuallyDrop disables drop. Useful when interfacing with C, or custom drop order. Memory leak if not manually dropped.",
    "rust_book_link": "https://doc.rust-lang.org/std/mem/struct.ManuallyDrop.html"
  },
  {
    "id": "expert-004",
    "category": "macros",
    "difficulty": 5,
    "type": "predict_output",
    "code": "macro_rules! lazy_static {\n    ($name:ident : $ty:ty = $init:expr) => {\n        static $name: std::sync::OnceLock<$ty> = std::sync::OnceLock::new();\n        \n        impl $name {\n            fn get() -> &'static $ty {\n                $name.get_or_init(|| $init)\n            }\n        }\n    };\n}",
    "question": "What pattern does this implement?",
    "options": [
      "Lazy static initialization - value created on first access",
      "Eager initialization",
      "Compile error - can't impl on static",
      "Thread-local storage"
    ],
    "correct": 0,
    "explanation": "OnceLock enables lazy initialization of statics. Common pattern for expensive one-time setup.",
    "rust_book_link": "https://doc.rust-lang.org/std/sync/struct.OnceLock.html"
  },
  {
    "id": "expert-005",
    "category": "async_await",
    "difficulty": 5,
    "type": "spot_error",
    "code": "async fn foo() -> impl Future<Output = i32> {\n    async { 42 }\n}",
    "question": "Is this redundant?",
    "options": [
      "Yes - async fn already returns impl Future",
      "No - double wrapping is required",
      "No - different Future types",
      "Compile error"
    ],
    "correct": 0,
    "explanation": "async fn returns Future automatically. The inner async {} creates a nested Future. Should just return 42.",
    "rust_book_link": "https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html"
  },
  {
    "id": "expert-006",
    "category": "ownership",
    "difficulty": 5,
    "type": "idiomatic",
    "code": "// Interior vs exterior mutability",
    "question": "When to use Cell/RefCell over regular &mut?",
    "options": [
      "When you need mutation through shared (&) references",
      "Always prefer interior mutability",
      "Only in unsafe code",
      "They're equivalent to &mut"
    ],
    "correct": 0,
    "explanation": "Interior mutability trades compile-time for runtime borrow checking. Use when architecture requires mutation through & refs.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch15-05-interior-mutability.html"
  },
  {
    "id": "expert-007",
    "category": "traits_generics",
    "difficulty": 5,
    "type": "will_compile",
    "code": "trait Foo<T> {\n    type Output;\n    fn process(&self, input: T) -> Self::Output;\n}\n\nimpl Foo<i32> for String {\n    type Output = usize;\n    fn process(&self, input: i32) -> usize {\n        self.len() + input as usize\n    }\n}",
    "question": "What's the difference: generic param vs associated type?",
    "options": [
      "Generic param T allows multiple impls per type, associated type allows one",
      "They're identical",
      "Associated types are faster",
      "Generic params are deprecated"
    ],
    "correct": 0,
    "explanation": "Can impl Foo<i32> and Foo<String> for same type. Associated types define one impl per type.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch19-03-advanced-traits.html"
  },
  {
    "id": "expert-008",
    "category": "unsafe",
    "difficulty": 5,
    "type": "fix_code",
    "code": "fn split_at_mut<T>(slice: &mut [T], mid: usize) -> (&mut [T], &mut [T]) {\n    let len = slice.len();\n    let ptr = slice.as_mut_ptr();\n    \n    unsafe {\n        (\n            std::slice::from_raw_parts_mut(ptr, mid),\n            std::slice::from_raw_parts_mut(ptr.add(mid), len - mid),\n        )\n    }\n}",
    "question": "Is this safe implementation?",
    "options": [
      "Yes - creates two non-overlapping mutable slices, standard pattern",
      "No - two mutable pointers to same data",
      "No - from_raw_parts_mut is always UB",
      "No - need to check mid <= len"
    ],
    "correct": 0,
    "explanation": "This is how std splits slices. Two pointers to different regions, meeting unsafe requirements. Should add bounds check though.",
    "rust_book_link": "https://doc.rust-lang.org/src/core/slice/mod.rs.html#1977"
  },
  {
    "id": "expert-009",
    "category": "macros",
    "difficulty": 5,
    "type": "predict_output",
    "code": "macro_rules! gen_impl {\n    ($($trait:ident),+) => {\n        $(\n            impl $trait for MyType {}\n        )+\n    };\n}\n\nstruct MyType;\ngen_impl!(Clone, Debug, Default);",
    "question": "What does this generate?",
    "options": [
      "Three separate impl blocks for MyType",
      "Single impl block with three traits",
      "Compile error - can't repeat impl",
      "Nothing - macros can't generate impls"
    ],
    "correct": 0,
    "explanation": "Repetition $( )+ expands to multiple impl blocks. Useful for generating boilerplate trait implementations.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch19-06-macros.html"
  },
  {
    "id": "expert-010",
    "category": "async_await",
    "difficulty": 5,
    "type": "idiomatic",
    "code": "// Stream vs Iterator",
    "question": "When to use Stream over Iterator?",
    "options": [
      "Stream for async values arriving over time, Iterator for sync",
      "Always use Stream in async code",
      "They're identical",
      "Iterator is deprecated"
    ],
    "correct": 0,
    "explanation": "Stream is async Iterator. Use for values produced asynchronously (network, timers). Iterator for sync sequences.",
    "rust_book_link": "https://rust-lang.github.io/async-book/05_streams/01_chapter.html"
  },
  {
    "id": "expert-011",
    "category": "traits_generics",
    "difficulty": 5,
    "type": "spot_error",
    "code": "fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &'a str \n    where 'b: 'a \n{\n    if x.len() > y.len() { x } else { y }\n}",
    "question": "What does 'b: 'a mean?",
    "options": [
      "'b outlives 'a - y lives at least as long as x",
      "'a outlives 'b",
      "Syntax error",
      "'a and 'b must be equal"
    ],
    "correct": 0,
    "explanation": "Lifetime bound 'b: 'a means 'b outlives 'a. Allows returning &'a even when sourced from y.",
    "rust_book_link": "https://doc.rust-lang.org/reference/trait-bounds.html#lifetime-bounds"
  },
  {
    "id": "expert-012",
    "category": "ownership",
    "difficulty": 5,
    "type": "will_compile",
    "code": "struct SelfRef {\n    value: String,\n    pointer: *const String,\n}\n\nimpl SelfRef {\n    fn new(value: String) -> Self {\n        let mut s = SelfRef {\n            value,\n            pointer: std::ptr::null(),\n        };\n        s.pointer = &s.value;\n        s\n    }\n}",
    "question": "What's the problem?",
    "options": [
      "Returning s moves it, invalidating self-reference - use Pin",
      "Can't have raw pointers in structs",
      "Nothing wrong",
      "value must be Box<String>"
    ],
    "correct": 0,
    "explanation": "Self-referential struct breaks when moved. s.pointer becomes dangling after return. Need Pin<Box<Self>>.",
    "rust_book_link": "https://doc.rust-lang.org/std/pin/index.html"
  },
  {
    "id": "expert-013",
    "category": "smart_pointers",
    "difficulty": 5,
    "type": "idiomatic",
    "code": "use std::sync::Arc;\nuse parking_lot::Mutex;\n\nstruct Data {\n    value: Arc<Mutex<i32>>,\n}",
    "question": "Why parking_lot::Mutex over std::sync::Mutex?",
    "options": [
      "Faster, no poisoning, smaller size - but loses poison detection",
      "Required by Arc",
      "Always better than std",
      "They're identical"
    ],
    "correct": 0,
    "explanation": "parking_lot is often faster and simpler (no poison), but std::sync provides poison detection for panic safety.",
    "rust_book_link": "https://docs.rs/parking_lot/"
  },
  {
    "id": "expert-014",
    "category": "unsafe",
    "difficulty": 5,
    "type": "predict_output",
    "code": "fn main() {\n    let x = vec![1, 2, 3];\n    let ptr = x.as_ptr();\n    drop(x);\n    unsafe {\n        println!(\"{}\", *ptr);\n    }\n}",
    "question": "What happens?",
    "options": [
      "Undefined behavior - use after free, ptr is dangling",
      "Prints 1",
      "Compile error",
      "Runtime panic"
    ],
    "correct": 0,
    "explanation": "drop() deallocates x's memory. Dereferencing ptr accesses freed memory - classic use-after-free UB.",
    "rust_book_link": "https://doc.rust-lang.org/nomicon/aliasing.html"
  },
  {
    "id": "expert-015",
    "category": "traits_generics",
    "difficulty": 5,
    "type": "fix_code",
    "code": "trait Container {\n    fn items(&self) -> &Vec<i32>;\n}",
    "question": "More flexible return type?",
    "options": [
      "Change to &[i32] - works with Vec, arrays, slices",
      "Change to Vec<i32> - owned",
      "Add impl Iterator<Item=i32>",
      "Current is best"
    ],
    "correct": 0,
    "explanation": "Returning &[i32] is more flexible than &Vec. Implementers can return references to any contiguous sequence.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch15-02-deref.html"
  },
  {
    "id": "expert-016",
    "category": "async_await",
    "difficulty": 5,
    "type": "spot_error",
    "code": "async fn process_all(items: Vec<String>) {\n    for item in items {\n        tokio::spawn(async move {\n            // process item\n        });\n    }\n}",
    "question": "What's the issue?",
    "options": [
      "Spawned tasks may outlive function, items processed after return",
      "Can't spawn in loop",
      "async move doesn't work here",
      "Nothing wrong"
    ],
    "correct": 0,
    "explanation": "spawn() doesn't wait for tasks. Function returns immediately, tasks run in background. Use join handles or task groups.",
    "rust_book_link": "https://tokio.rs/tokio/tutorial/spawning"
  },
  {
    "id": "expert-017",
    "category": "macros",
    "difficulty": 5,
    "type": "will_compile",
    "code": "#[cfg(target_os = \"linux\")]\nfn platform_specific() {\n    println!(\"Linux\");\n}\n\n#[cfg(not(target_os = \"linux\"))]\nfn platform_specific() {\n    println!(\"Other\");\n}",
    "question": "What is this pattern?",
    "options": [
      "Conditional compilation - includes different code per platform",
      "Runtime branching",
      "Compile error - duplicate functions",
      "Macro-based polymorphism"
    ],
    "correct": 0,
    "explanation": "#[cfg] is compile-time. Only one function definition included based on target. Zero runtime cost.",
    "rust_book_link": "https://doc.rust-lang.org/reference/conditional-compilation.html"
  },
  {
    "id": "expert-018",
    "category": "lifetimes",
    "difficulty": 5,
    "type": "predict_output",
    "code": "fn foo() -> &'static str {\n    let s = String::from(\"hello\");\n    Box::leak(s.into_boxed_str())\n}",
    "question": "Is Box::leak a valid pattern?",
    "options": [
      "Yes - intentionally leaks memory to get 'static lifetime",
      "No - always a bug",
      "No - Box can't leak",
      "Yes but only in unsafe"
    ],
    "correct": 0,
    "explanation": "Box::leak prevents drop, giving 'static ref. Valid for long-lived data, but creates intentional memory leak.",
    "rust_book_link": "https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak"
  },
  {
    "id": "expert-019",
    "category": "ownership",
    "difficulty": 5,
    "type": "idiomatic",
    "code": "// Zero-cost abstraction",
    "question": "What makes Rust abstractions zero-cost?",
    "options": [
      "Compiler optimizations eliminate overhead at compile time",
      "Runtime garbage collection",
      "Dynamic dispatch is free",
      "All abstractions have cost"
    ],
    "correct": 0,
    "explanation": "Monomorphization, inlining, and other opts mean abstractions compile to same code as hand-written. No runtime cost.",
    "rust_book_link": "https://blog.rust-lang.org/2015/05/11/traits.html"
  },
  {
    "id": "expert-020",
    "category": "smart_pointers",
    "difficulty": 5,
    "type": "fix_code",
    "code": "use std::sync::Arc;\nuse std::thread;\n\nlet data = Arc::new(vec![1, 2, 3]);\n\nlet handle = thread::spawn(|| {\n    println!(\"{:?}\", data);\n});",
    "question": "How to fix closure capture?",
    "options": [
      "Clone Arc before closure: let data = Arc::clone(&data);",
      "Use move keyword only",
      "data doesn't need cloning",
      "Use &data in closure"
    ],
    "correct": 0,
    "explanation": "Need to clone Arc before move closure to give ownership to thread. Arc::clone increments refcount.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch16-03-shared-state.html"
  },
  {
    "id": "expert-021",
    "category": "unsafe",
    "difficulty": 5,
    "type": "spot_error",
    "code": "fn extend_lifetime<'a>(s: &str) -> &'a str {\n    s\n}",
    "question": "Is this safe?",
    "options": [
      "No - caller can create dangling reference by passing short-lived str",
      "Yes - just returns input",
      "Yes - lifetime elision handles it",
      "No - need unsafe block"
    ],
    "correct": 0,
    "explanation": "Allows caller to extend lifetime arbitrarily. Can return reference outliving source. Classic lifetime hole.",
    "rust_book_link": "https://doc.rust-lang.org/nomicon/lifetimes.html"
  },
  {
    "id": "expert-022",
    "category": "traits_generics",
    "difficulty": 5,
    "type": "will_compile",
    "code": "trait Animal {\n    const LEGS: u32;\n}\n\nstruct Dog;\nimpl Animal for Dog {\n    const LEGS: u32 = 4;\n}\n\nfn count_legs<T: Animal>() -> u32 {\n    T::LEGS\n}",
    "question": "What are const trait items useful for?",
    "options": [
      "Compile-time constants associated with types/traits",
      "Runtime configuration",
      "Dynamic dispatch",
      "Only for documentation"
    ],
    "correct": 0,
    "explanation": "Associated consts provide compile-time values tied to types. Useful for sizes, capacities, feature flags.",
    "rust_book_link": "https://doc.rust-lang.org/reference/items/associated-items.html#associated-constants"
  },
  {
    "id": "expert-023",
    "category": "async_await",
    "difficulty": 5,
    "type": "predict_output",
    "code": "use tokio::time::{sleep, Duration};\n\n#[tokio::main]\nasync fn main() {\n    let fut = async {\n        sleep(Duration::from_secs(1)).await;\n        println!(\"Done\");\n    };\n    println!(\"Started\");\n}",
    "question": "What prints?",
    "options": [
      "Only 'Started' - future never awaited",
      "'Started' then 'Done' after 1 sec",
      "'Done' then 'Started'",
      "Compile error"
    ],
    "correct": 0,
    "explanation": "Futures are lazy. Without .await, fut is created but never executed. Only 'Started' prints.",
    "rust_book_link": "https://rust-lang.github.io/async-book/02_execution/01_chapter.html"
  },
  {
    "id": "expert-024",
    "category": "macros",
    "difficulty": 5,
    "type": "idiomatic",
    "code": "// Hygiene in macros",
    "question": "What is macro hygiene?",
    "options": [
      "Prevents name collisions between macro and call site scopes",
      "Memory safety for macros",
      "Type checking for macros",
      "Macro documentation"
    ],
    "correct": 0,
    "explanation": "Hygiene ensures macro-internal variables don't conflict with caller's. Most macros are hygienic by default.",
    "rust_book_link": "https://doc.rust-lang.org/reference/macros-by-example.html#hygiene"
  },
  {
    "id": "expert-025",
    "category": "ownership",
    "difficulty": 5,
    "type": "fix_code",
    "code": "fn returns_closure() -> Box<dyn Fn(i32) -> i32> {\n    let num = 5;\n    Box::new(|x| x + num)\n}",
    "question": "Why does this fail?",
    "options": [
      "Closure captures num by reference, but num dropped - use move",
      "Can't return closures",
      "Box doesn't work with Fn",
      "Nothing wrong"
    ],
    "correct": 0,
    "explanation": "Closure borrows num, but it goes out of scope. Use move || to capture by value: Box::new(move |x| x + num)",
    "error_line": 3,
    "rust_book_link": "https://doc.rust-lang.org/book/ch13-01-closures.html"
  }
]
