[
  {
    "id": "own-001",
    "category": "ownership",
    "difficulty": 2,
    "type": "spot_error",
    "code": "fn main() {\n    let s = String::from(\"hello\");\n    let r1 = &s;\n    let r2 = &mut s;\n    println!(\"{}, {}\", r1, r2);\n}",
    "question": "What's wrong with this code?",
    "options": [
      "Cannot have mutable and immutable references simultaneously",
      "String::from is deprecated",
      "println! cannot take two references",
      "Missing semicolon"
    ],
    "correct": 0,
    "explanation": "Rust's borrowing rules prevent having a mutable reference while immutable references exist. The immutable reference r1 is still in scope when we try to create r2.",
    "error_line": 4,
    "rust_book_link": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html"
  },
  {
    "id": "own-002",
    "category": "ownership",
    "difficulty": 1,
    "type": "will_compile",
    "code": "fn main() {\n    let x = 5;\n    let y = x;\n    println!(\"{}\", x);\n}",
    "question": "Will this code compile?",
    "options": [
      "Yes, because integers implement Copy",
      "No, x was moved to y",
      "Yes, but only in release mode",
      "No, x is immutable"
    ],
    "correct": 0,
    "explanation": "Integers implement the Copy trait, so assignment creates a copy rather than a move. Both x and y remain valid.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#stack-only-data-copy"
  },
  {
    "id": "own-003",
    "category": "ownership",
    "difficulty": 3,
    "type": "fix_code",
    "code": "fn main() {\n    let mut v = vec![1, 2, 3];\n    let first = &v[0];\n    v.push(4);\n    println!(\"First: {}\", first);\n}",
    "question": "How do you fix this borrowing violation?",
    "options": [
      "Move the push before creating the reference",
      "Clone v before pushing",
      "Use Rc<RefCell<Vec<i32>>>",
      "Make first mutable"
    ],
    "correct": 0,
    "explanation": "The immutable borrow 'first' prevents the mutable borrow needed for push. Moving the push before the borrow resolves this.",
    "error_line": 3
  },
  {
    "id": "own-004",
    "category": "ownership",
    "difficulty": 2,
    "type": "predict_output",
    "code": "fn take_ownership(s: String) {\n    println!(\"{}\", s);\n}\n\nfn main() {\n    let s = String::from(\"hello\");\n    take_ownership(s);\n    println!(\"{}\", s);\n}",
    "question": "What happens when this runs?",
    "options": [
      "Compile error: value borrowed after move",
      "Prints 'hello' twice",
      "Runtime panic",
      "Prints 'hello' then empty string"
    ],
    "correct": 0,
    "explanation": "String doesn't implement Copy, so s is moved into take_ownership. Using s afterward is a compile error.",
    "error_line": 8
  },
  {
    "id": "life-001",
    "category": "lifetimes",
    "difficulty": 3,
    "type": "fill_blank",
    "code": "fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}",
    "question": "What does the lifetime 'a represent?",
    "options": [
      "The returned reference lives as long as the shorter of x or y",
      "The returned reference lives forever",
      "x and y must have identical lifetimes",
      "The function can only be called once"
    ],
    "correct": 0,
    "explanation": "The lifetime annotation 'a means the returned reference will be valid for the overlap of x and y's lifetimes (i.e., the shorter lifetime).",
    "rust_book_link": "https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html"
  },
  {
    "id": "life-002",
    "category": "lifetimes",
    "difficulty": 4,
    "type": "spot_error",
    "code": "struct Excerpt<'a> {\n    part: &'a str,\n}\n\nfn main() {\n    let novel = String::from(\"Call me Ishmael.\");\n    let excerpt;\n    {\n        let first_sentence = novel.split('.').next().unwrap();\n        excerpt = Excerpt { part: first_sentence };\n    }\n    println!(\"{}\", excerpt.part);\n}",
    "question": "Is there a lifetime issue here?",
    "options": [
      "No issue - first_sentence outlives excerpt",
      "Yes - first_sentence dropped before excerpt is used",
      "Yes - novel needs to be mutable",
      "No issue - String has 'static lifetime"
    ],
    "correct": 0,
    "explanation": "first_sentence is a &str slice into novel, which outlives the inner scope. The excerpt remains valid.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-annotations-in-struct-definitions"
  },
  {
    "id": "err-001",
    "category": "error_handling",
    "difficulty": 2,
    "type": "idiomatic",
    "code": "fn read_number(s: &str) -> Result<i32, std::num::ParseIntError> {\n    s.parse::<i32>()\n}",
    "question": "Which is the most idiomatic way to use this?",
    "options": [
      "let num = read_number(\"42\")?;",
      "let num = read_number(\"42\").unwrap();",
      "let num = match read_number(\"42\") { Ok(n) => n, Err(_) => panic!() };",
      "let num = read_number(\"42\").expect(\"parse failed\");"
    ],
    "correct": 0,
    "explanation": "The ? operator is the idiomatic way to propagate errors, making code clean and composable.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator"
  },
  {
    "id": "err-002",
    "category": "error_handling",
    "difficulty": 3,
    "type": "fix_code",
    "code": "fn divide(a: i32, b: i32) -> i32 {\n    if b == 0 {\n        panic!(\"Division by zero\");\n    }\n    a / b\n}",
    "question": "How should this be refactored for better error handling?",
    "options": [
      "Return Option<i32> or Result<i32, Error>",
      "Use assert! instead of panic!",
      "Add #[must_use] attribute",
      "Use unwrap_or_default()"
    ],
    "correct": 0,
    "explanation": "Returning Option or Result allows callers to handle the error case, making the function more composable and testable.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch09-00-error-handling.html"
  },
  {
    "id": "err-003",
    "category": "error_handling",
    "difficulty": 2,
    "type": "predict_output",
    "code": "fn main() {\n    let x: Option<i32> = None;\n    let y = x.unwrap_or(5);\n    println!(\"{}\", y);\n}",
    "question": "What does this print?",
    "options": [
      "5",
      "None",
      "Panics with 'called Option::unwrap() on a None value'",
      "0"
    ],
    "correct": 0,
    "explanation": "unwrap_or provides a default value when the Option is None, avoiding a panic.",
    "rust_book_link": "https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or"
  },
  {
    "id": "trait-001",
    "category": "traits_generics",
    "difficulty": 3,
    "type": "spot_error",
    "code": "fn print_it<T>(item: T) {\n    println!(\"{}\", item);\n}",
    "question": "What's missing?",
    "options": [
      "T must be bound with Display trait",
      "T must be 'static",
      "T must implement Copy",
      "Nothing, this works fine"
    ],
    "correct": 0,
    "explanation": "println! with {} requires the Display trait. The function needs: fn print_it<T: Display>(item: T)",
    "error_line": 2,
    "rust_book_link": "https://doc.rust-lang.org/book/ch10-02-traits.html#trait-bound-syntax"
  },
  {
    "id": "trait-002",
    "category": "traits_generics",
    "difficulty": 4,
    "type": "idiomatic",
    "code": "// Which syntax is preferred for multiple trait bounds?",
    "question": "Choose the most idiomatic multiple trait bound syntax:",
    "options": [
      "fn foo<T>(item: T) where T: Display + Clone",
      "fn foo<T: Display + Clone>(item: T)",
      "fn foo<T>(item: T) { static_assert!(T: Display + Clone); }",
      "Both A and B are equally idiomatic"
    ],
    "correct": 3,
    "explanation": "Both forms are idiomatic. Use inline bounds for simple cases, where clauses for complex bounds or better readability.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch10-02-traits.html#clearer-trait-bounds-with-where-clauses"
  },
  {
    "id": "trait-003",
    "category": "traits_generics",
    "difficulty": 3,
    "type": "will_compile",
    "code": "trait Animal {\n    fn make_sound(&self);\n}\n\nstruct Dog;\n\nimpl Animal for Dog {\n    fn make_sound(&self) {\n        println!(\"Woof!\");\n    }\n}\n\nfn main() {\n    let animals: Vec<Animal> = vec![Dog];\n}",
    "question": "Will this compile?",
    "options": [
      "No, trait objects need Box or & (e.g., Vec<Box<dyn Animal>>)",
      "Yes, traits can be used directly as types",
      "No, Dog needs to derive Animal",
      "Yes, but only with #![feature(trait_upcasting)]"
    ],
    "correct": 0,
    "explanation": "Trait objects must be behind a pointer (Box, &, etc.) because they're dynamically sized. Use Vec<Box<dyn Animal>>.",
    "error_line": 14,
    "rust_book_link": "https://doc.rust-lang.org/book/ch17-02-trait-objects.html"
  },
  {
    "id": "iter-001",
    "category": "iterators_closures",
    "difficulty": 2,
    "type": "idiomatic",
    "code": "let v = vec![1, 2, 3, 4, 5];",
    "question": "Most idiomatic way to sum all elements?",
    "options": [
      "v.iter().sum()",
      "let mut sum = 0; for x in v { sum += x; }",
      "v.into_iter().fold(0, |acc, x| acc + x)",
      "v.iter().reduce(|a, b| a + b).unwrap()"
    ],
    "correct": 0,
    "explanation": "The sum() method is specifically designed for this use case and is the most concise and idiomatic.",
    "rust_book_link": "https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.sum"
  },
  {
    "id": "iter-002",
    "category": "iterators_closures",
    "difficulty": 3,
    "type": "predict_output",
    "code": "let v = vec![1, 2, 3];\nlet doubled: Vec<_> = v.iter().map(|x| x * 2).collect();\nprintln!(\"{:?}\", doubled);",
    "question": "What does this print?",
    "options": [
      "[2, 4, 6]",
      "[1, 2, 3]",
      "Compile error",
      "[]"
    ],
    "correct": 0,
    "explanation": "map() transforms each element, and collect() gathers the results into a Vec. Output: [2, 4, 6]",
    "rust_book_link": "https://doc.rust-lang.org/book/ch13-02-iterators.html"
  },
  {
    "id": "iter-003",
    "category": "iterators_closures",
    "difficulty": 4,
    "type": "spot_error",
    "code": "let mut v = vec![1, 2, 3];\nv.iter().for_each(|x| *x += 1);\nprintln!(\"{:?}\", v);",
    "question": "What's wrong?",
    "options": [
      "iter() gives immutable refs; need iter_mut()",
      "for_each doesn't exist",
      "Can't modify v while iterating",
      "Nothing, this works"
    ],
    "correct": 0,
    "explanation": "iter() provides &T. To modify elements, use iter_mut() which provides &mut T.",
    "error_line": 2,
    "rust_book_link": "https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter_mut"
  },
  {
    "id": "match-001",
    "category": "pattern_matching",
    "difficulty": 2,
    "type": "fix_code",
    "code": "match some_option {\n    Some(x) => println!(\"{}\", x),\n}",
    "question": "What's missing?",
    "options": [
      "None arm - patterns must be exhaustive",
      "Default case with 'default =>' ",
      "Type annotation for x",
      "Nothing, this is valid"
    ],
    "correct": 0,
    "explanation": "Rust requires exhaustive pattern matching. You must handle the None case or use a wildcard pattern.",
    "error_line": 1,
    "rust_book_link": "https://doc.rust-lang.org/book/ch06-02-match.html#matches-are-exhaustive"
  },
  {
    "id": "match-002",
    "category": "pattern_matching",
    "difficulty": 3,
    "type": "idiomatic",
    "code": "let x = Some(5);",
    "question": "Most idiomatic way to run code only if Some?",
    "options": [
      "if let Some(val) = x { /* use val */ }",
      "match x { Some(val) => { /* use val */ }, None => {} }",
      "if x.is_some() { let val = x.unwrap(); /* use val */ }",
      "x.map(|val| { /* use val */ });"
    ],
    "correct": 0,
    "explanation": "if let is specifically designed for this pattern and is more concise than a match with empty None arm.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch06-03-if-let.html"
  },
  {
    "id": "match-003",
    "category": "pattern_matching",
    "difficulty": 4,
    "type": "predict_output",
    "code": "let x = 5;\nmatch x {\n    1..=5 => println!(\"one through five\"),\n    _ => println!(\"something else\"),\n}",
    "question": "What prints?",
    "options": [
      "one through five",
      "something else",
      "Compile error: range patterns not allowed",
      "5"
    ],
    "correct": 0,
    "explanation": "Range patterns (1..=5) match inclusive ranges. 5 is in the range, so first arm matches.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#matching-ranges-of-values-with-"
  },
  {
    "id": "async-001",
    "category": "async_await",
    "difficulty": 3,
    "type": "spot_error",
    "code": "async fn fetch_data() -> String {\n    \"data\".to_string()\n}\n\nfn main() {\n    let data = fetch_data();\n    println!(\"{}\", data);\n}",
    "question": "What's wrong?",
    "options": [
      "async functions return Future, need .await and async runtime",
      "fetch_data needs to be marked unsafe",
      "String can't be returned from async fn",
      "main needs #[tokio::main]"
    ],
    "correct": 0,
    "explanation": "async fn returns a Future that must be awaited. Also need an async runtime and async context.",
    "error_line": 6,
    "rust_book_link": "https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html"
  },
  {
    "id": "async-002",
    "category": "async_await",
    "difficulty": 4,
    "type": "will_compile",
    "code": "#[tokio::main]\nasync fn main() {\n    let future = async {\n        println!(\"Hello\");\n    };\n    println!(\"World\");\n}",
    "question": "What happens?",
    "options": [
      "Prints 'World' only - future never awaited",
      "Prints 'Hello' then 'World'",
      "Compile error",
      "Prints 'World' then 'Hello'"
    ],
    "correct": 0,
    "explanation": "Futures are lazy - they don't execute until awaited. The async block is never awaited, so only 'World' prints.",
    "rust_book_link": "https://rust-lang.github.io/async-book/02_execution/01_chapter.html"
  },
  {
    "id": "std-001",
    "category": "std_library",
    "difficulty": 2,
    "type": "idiomatic",
    "code": "let s = \"hello world\";",
    "question": "How to split into words idiomatically?",
    "options": [
      "s.split_whitespace()",
      "s.split(' ')",
      "s.split(\" \")",
      "All are equally idiomatic"
    ],
    "correct": 0,
    "explanation": "split_whitespace() handles all whitespace chars (spaces, tabs, newlines) and consecutive whitespace correctly.",
    "rust_book_link": "https://doc.rust-lang.org/std/primitive.str.html#method.split_whitespace"
  },
  {
    "id": "std-002",
    "category": "std_library",
    "difficulty": 3,
    "type": "predict_output",
    "code": "let v = vec![1, 2, 3];\nlet v2 = v.clone();\nprintln!(\"{}\", v.len() + v2.len());",
    "question": "What prints?",
    "options": [
      "6",
      "3",
      "Compile error",
      "Runtime panic"
    ],
    "correct": 0,
    "explanation": "clone() creates a deep copy. Both v and v2 have length 3, so 3 + 3 = 6.",
    "rust_book_link": "https://doc.rust-lang.org/std/clone/trait.Clone.html"
  },
  {
    "id": "macro-001",
    "category": "macros",
    "difficulty": 2,
    "type": "spot_error",
    "code": "println!(\"x = {}\");",
    "question": "What's wrong?",
    "options": [
      "Missing argument for {}",
      "Should use print! instead",
      "Needs #[macro_use]",
      "Nothing wrong"
    ],
    "correct": 0,
    "explanation": "The format string has a placeholder {} but no corresponding argument. Should be println!(\"x = {}\", x);",
    "error_line": 1
  },
  {
    "id": "macro-002",
    "category": "macros",
    "difficulty": 3,
    "type": "idiomatic",
    "code": "let v = vec![1, 2, 3];",
    "question": "What does vec! macro expand to approximately?",
    "options": [
      "{ let mut temp = Vec::new(); temp.push(1); temp.push(2); temp.push(3); temp }",
      "Vector::from([1, 2, 3])",
      "Array::to_vec(&[1, 2, 3])",
      "[1, 2, 3].into()"
    ],
    "correct": 0,
    "explanation": "vec! is syntactic sugar that creates a Vec and pushes each element (optimized with capacity pre-allocation).",
    "rust_book_link": "https://doc.rust-lang.org/std/macro.vec.html"
  },
  {
    "id": "unsafe-001",
    "category": "unsafe",
    "difficulty": 4,
    "type": "spot_error",
    "code": "let mut num = 5;\nlet r1 = &num as *const i32;\nlet r2 = &mut num as *mut i32;\nunsafe {\n    println!(\"{}\", *r1);\n}",
    "question": "What's the issue?",
    "options": [
      "Creating mutable and immutable raw pointers simultaneously is undefined behavior",
      "Raw pointers can't be dereferenced",
      "println! can't be used in unsafe blocks",
      "Nothing, this is safe"
    ],
    "correct": 0,
    "explanation": "While creating raw pointers is safe, having aliasing mutable and immutable raw pointers can lead to UB if used incorrectly.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html"
  },
  {
    "id": "unsafe-002",
    "category": "unsafe",
    "difficulty": 5,
    "type": "will_compile",
    "code": "fn main() {\n    let address = 0x012345usize;\n    let r = address as *const i32;\n    unsafe {\n        println!(\"{}\", *r);\n    }\n}",
    "question": "Will this compile?",
    "options": [
      "Yes, but likely causes runtime crash/UB",
      "No, can't cast usize to pointer",
      "Yes, and safely prints 0",
      "No, println! not allowed in unsafe"
    ],
    "correct": 0,
    "explanation": "This compiles but dereferencing an arbitrary memory address is undefined behavior and will likely crash.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer"
  },
  {
    "id": "life-003",
    "category": "lifetimes",
    "difficulty": 4,
    "type": "fix_code",
    "code": "struct Foo {\n    x: &str,\n}",
    "question": "What's needed to make this compile?",
    "options": [
      "Add lifetime parameter: struct Foo<'a> { x: &'a str }",
      "Change to String instead of &str",
      "Add #[derive(Lifetime)]",
      "Use Box<str>"
    ],
    "correct": 0,
    "explanation": "References in structs need explicit lifetime annotations so the compiler can track how long they're valid.",
    "error_line": 2,
    "rust_book_link": "https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-annotations-in-struct-definitions"
  },
  {
    "id": "own-005",
    "category": "ownership",
    "difficulty": 3,
    "type": "idiomatic",
    "code": "fn process(data: &Vec<String>) { }",
    "question": "What's a better signature?",
    "options": [
      "fn process(data: &[String])",
      "fn process(data: Vec<String>)",
      "fn process(data: &mut Vec<String>)",
      "fn process(data: Box<Vec<String>>)"
    ],
    "correct": 0,
    "explanation": "Using &[T] instead of &Vec<T> is more flexible - it accepts Vec, arrays, and slices. This is called 'deref coercion'.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods"
  },
  {
    "id": "err-004",
    "category": "error_handling",
    "difficulty": 3,
    "type": "idiomatic",
    "code": "fn parse_config(s: &str) -> Result<Config, Box<dyn Error>> { }",
    "question": "When is Box<dyn Error> preferred over specific error types?",
    "options": [
      "In applications when you don't want to define custom error types",
      "In libraries for public APIs",
      "Never, always use anyhow::Error",
      "Only in async code"
    ],
    "correct": 0,
    "explanation": "Box<dyn Error> is convenient for applications. Libraries should use specific error types for better API clarity.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html"
  },
  {
    "id": "trait-004",
    "category": "traits_generics",
    "difficulty": 4,
    "type": "predict_output",
    "code": "trait Greet {\n    fn greet(&self) { println!(\"Hello!\"); }\n}\n\nstruct Person;\n\nimpl Greet for Person {\n    fn greet(&self) { println!(\"Hi!\"); }\n}\n\nfn main() {\n    let p = Person;\n    p.greet();\n}",
    "question": "What prints?",
    "options": [
      "Hi!",
      "Hello!",
      "Compile error: ambiguous method",
      "Both messages"
    ],
    "correct": 0,
    "explanation": "The implementation in the impl block overrides the default trait implementation. Prints 'Hi!'.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch10-02-traits.html#default-implementations"
  },
  {
    "id": "iter-004",
    "category": "iterators_closures",
    "difficulty": 3,
    "type": "spot_error",
    "code": "let v = vec![1, 2, 3];\nlet sum = v.iter().sum();\nprintln!(\"{}\", sum);",
    "question": "What's wrong?",
    "options": [
      "sum needs type annotation: sum::<i32>()",
      "iter() should be into_iter()",
      "sum() doesn't exist",
      "Nothing wrong"
    ],
    "correct": 0,
    "explanation": "sum() needs to know the target type. Use type annotation: let sum: i32 = ... or v.iter().sum::<i32>()",
    "error_line": 2
  },
  {
    "id": "match-004",
    "category": "pattern_matching",
    "difficulty": 3,
    "type": "idiomatic",
    "code": "let point = (0, 5);",
    "question": "How to destructure and use only y coordinate?",
    "options": [
      "let (_, y) = point;",
      "let (x, y) = point; // ignore x",
      "let y = point.1;",
      "let [_, y] = point;"
    ],
    "correct": 0,
    "explanation": "Using _ in destructuring explicitly shows you're ignoring that value. More idiomatic than accessing .1.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#ignoring-values-in-a-pattern"
  },
  {
    "id": "own-006",
    "category": "ownership",
    "difficulty": 2,
    "type": "will_compile",
    "code": "fn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1;\n    let s3 = s1;\n    println!(\"{}\", s2);\n}",
    "question": "Will this compile?",
    "options": [
      "No, s1 moved to s2, can't move again to s3",
      "Yes, String implements Copy",
      "Yes, but s3 will be empty",
      "No, println! can't use moved value"
    ],
    "correct": 0,
    "explanation": "s1 is moved to s2 in line 3. Line 4 tries to use s1 again, which is a compile error.",
    "error_line": 4,
    "rust_book_link": "https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#variables-and-data-interacting-with-move"
  },
  {
    "id": "std-003",
    "category": "std_library",
    "difficulty": 2,
    "type": "idiomatic",
    "code": "let s = \"42\";",
    "question": "Best way to convert to i32?",
    "options": [
      "s.parse::<i32>()",
      "i32::from_str(s)",
      "s.to_i32()",
      "s.into::<i32>()"
    ],
    "correct": 0,
    "explanation": "parse() is the idiomatic method for parsing strings into numbers. It returns Result<T, ParseError>.",
    "rust_book_link": "https://doc.rust-lang.org/std/primitive.str.html#method.parse"
  },
  {
    "id": "err-005",
    "category": "error_handling",
    "difficulty": 4,
    "type": "spot_error",
    "code": "fn read_file() -> Result<String, io::Error> {\n    let mut file = File::open(\"data.txt\")?;\n    let mut contents = String::new();\n    file.read_to_string(&mut contents)?;\n    Ok(contents)\n}\n\nfn main() {\n    let data = read_file()?;\n    println!(\"{}\", data);\n}",
    "question": "What's wrong with main?",
    "options": [
      "main must return Result to use ?",
      "? operator not allowed in main",
      "read_file() needs .unwrap()",
      "Nothing wrong"
    ],
    "correct": 0,
    "explanation": "The ? operator can only be used in functions that return Result or Option. main needs: fn main() -> Result<(), Box<dyn Error>>",
    "error_line": 9,
    "rust_book_link": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator"
  },
  {
    "id": "trait-005",
    "category": "traits_generics",
    "difficulty": 5,
    "type": "idiomatic",
    "code": "fn process_items(items: Vec<Box<dyn Display>>) { }",
    "question": "What's a potential issue with this signature?",
    "options": [
      "Not object-safe - can't return impl Iterator or clone",
      "Box has overhead, should use &dyn",
      "Display requires 'static lifetime",
      "Should use impl Display instead"
    ],
    "correct": 1,
    "explanation": "If you don't need ownership, &dyn Display is more efficient than Box<dyn Display>. Consider Vec<&dyn Display> instead.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch"
  },
  {
    "id": "iter-005",
    "category": "iterators_closures",
    "difficulty": 4,
    "type": "predict_output",
    "code": "let v = vec![1, 2, 3, 4, 5];\nlet result: Vec<_> = v.iter()\n    .filter(|&x| x % 2 == 0)\n    .map(|x| x * 2)\n    .collect();\nprintln!(\"{:?}\", result);",
    "question": "What prints?",
    "options": [
      "[4, 8]",
      "[2, 4, 6, 8, 10]",
      "[2, 4]",
      "Compile error"
    ],
    "correct": 0,
    "explanation": "filter keeps only even numbers (2, 4), then map doubles them (4, 8). Output: [4, 8]",
    "rust_book_link": "https://doc.rust-lang.org/book/ch13-02-iterators.html"
  },
  {
    "id": "async-003",
    "category": "async_await",
    "difficulty": 5,
    "type": "spot_error",
    "code": "#[tokio::main]\nasync fn main() {\n    let mut handles = vec![];\n    for i in 0..10 {\n        handles.push(tokio::spawn(async {\n            println!(\"{}\", i);\n        }));\n    }\n}",
    "question": "What's the issue?",
    "options": [
      "Closure captures i by reference, but i doesn't live long enough",
      "tokio::spawn requires Send bound",
      "Can't use println! in async block",
      "Nothing wrong"
    ],
    "correct": 0,
    "explanation": "i is captured by reference, but the loop variable doesn't outlive the spawned tasks. Use async move { } to capture by value.",
    "error_line": 5,
    "rust_book_link": "https://rust-lang.github.io/async-book/03_async_await/01_chapter.html"
  },
  {
    "id": "match-005",
    "category": "pattern_matching",
    "difficulty": 4,
    "type": "idiomatic",
    "code": "enum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n}",
    "question": "How to match Move and bind coordinates?",
    "options": [
      "Message::Move { x, y } => { }",
      "Message::Move(x, y) => { }",
      "Message::Move { .x, .y } => { }",
      "Message::Move => { let x = msg.x; }"
    ],
    "correct": 0,
    "explanation": "Struct-like enum variants are destructured with { field_name, ... } syntax.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#destructuring-enums"
  },
  {
    "id": "life-004",
    "category": "lifetimes",
    "difficulty": 5,
    "type": "will_compile",
    "code": "fn first_word(s: &str) -> &str {\n    let bytes = s.as_bytes();\n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return &s[0..i];\n        }\n    }\n    &s[..]\n}",
    "question": "Does this need explicit lifetime annotations?",
    "options": [
      "No, lifetime elision rules apply",
      "Yes, needs 'a on both parameters",
      "Yes, but only on return type",
      "No, because it uses slices"
    ],
    "correct": 0,
    "explanation": "Lifetime elision rule: when there's one input lifetime, it's assigned to all output lifetimes. Explicit annotations not needed.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision"
  },
  {
    "id": "macro-001",
    "category": "macros",
    "difficulty": 3,
    "type": "spot_error",
    "code": "macro_rules! double {\n    ($x:expr) => { $x + $x };\n}\n\nfn main() {\n    let result = double!(2 + 3);\n    println!(\"{}\", result);\n}",
    "question": "What does this print?",
    "options": [
      "8 (due to macro hygiene issues - expands to 2 + 3 + 2 + 3)",
      "10",
      "Compile error",
      "5"
    ],
    "correct": 0,
    "explanation": "The macro expands to '2 + 3 + 2 + 3' which equals 8, not 10. Use parentheses: ($x) + ($x) to fix.",
    "error_line": 2,
    "rust_book_link": "https://doc.rust-lang.org/book/ch19-06-macros.html"
  },
  {
    "id": "macro-002",
    "category": "macros",
    "difficulty": 4,
    "type": "fix_code",
    "code": "macro_rules! create_function {\n    ($func_name:ident) => {\n        fn $func_name() {\n            println!(\"You called {:?}()\", stringify!($func_name));\n        }\n    };\n}\n\ncreate_function!(foo);\ncreate_function!(bar);",
    "question": "What does stringify! do in this macro?",
    "options": [
      "Converts the identifier to a string literal at compile time",
      "Converts the value to a String at runtime",
      "Formats the identifier for debug output",
      "Creates a static string reference"
    ],
    "correct": 0,
    "explanation": "stringify! converts tokens into string literals during macro expansion at compile time, without runtime overhead.",
    "rust_book_link": "https://doc.rust-lang.org/std/macro.stringify.html"
  },
  {
    "id": "macro-003",
    "category": "macros",
    "difficulty": 5,
    "type": "will_compile",
    "code": "macro_rules! calculate {\n    (eval $e:expr) => {{\n        let val: usize = $e;\n        println!(\"{} = {}\", stringify!{$e}, val);\n    }};\n}\n\nfn main() {\n    calculate! {\n        eval 1 + 2\n    }\n}",
    "question": "Will this compile?",
    "options": [
      "Yes, the double braces create a block expression",
      "No, invalid macro syntax",
      "No, stringify needs parentheses",
      "Yes, but only in Rust 2021 edition"
    ],
    "correct": 0,
    "explanation": "The {{ }} creates a block expression in the macro, allowing local variables. This is a common pattern for hygiene.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch19-06-macros.html"
  },
  {
    "id": "macro-004",
    "category": "macros",
    "difficulty": 3,
    "type": "predict_output",
    "code": "macro_rules! my_vec {\n    ( $( $x:expr ),* ) => {\n        {\n            let mut temp_vec = Vec::new();\n            $(\n                temp_vec.push($x);\n            )*\n            temp_vec\n        }\n    };\n}\n\nfn main() {\n    let v = my_vec![1, 2, 3];\n    println!(\"{:?}\", v);\n}",
    "question": "What does this print?",
    "options": [
      "[1, 2, 3]",
      "Compile error: repetition syntax",
      "[3]",
      "[]"
    ],
    "correct": 0,
    "explanation": "The $( )* pattern repeats the code for each comma-separated expression, creating a vector with all elements.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming"
  },
  {
    "id": "macro-005",
    "category": "macros",
    "difficulty": 4,
    "type": "spot_error",
    "code": "macro_rules! make_fn {\n    ($name:ident, $value:expr) => {\n        fn $name() -> i32 {\n            $value\n        }\n    };\n}\n\nmake_fn!(get_five, 5);\nmake_fn!(get_x, x);",
    "question": "What's the issue?",
    "options": [
      "x is not defined in the macro invocation context",
      "Can't use expr in return position",
      "Function names must be quoted",
      "Nothing, this works fine"
    ],
    "correct": 0,
    "explanation": "The second invocation tries to use 'x' which doesn't exist. Macros don't capture variables from the caller's scope.",
    "error_line": 10,
    "rust_book_link": "https://doc.rust-lang.org/book/ch19-06-macros.html"
  },
  {
    "id": "macro-006",
    "category": "macros",
    "difficulty": 5,
    "type": "idiomatic",
    "code": "// Which macro pattern is more correct?",
    "question": "For a macro that takes optional trailing comma:",
    "options": [
      "($($x:expr),* $(,)?) - allows optional trailing comma",
      "($($x:expr),*) - no trailing comma",
      "($($x:expr,)*) - requires trailing comma",
      "All are equivalent"
    ],
    "correct": 0,
    "explanation": "The $(,)? pattern allows an optional trailing comma, matching Rust's standard syntax conventions.",
    "rust_book_link": "https://doc.rust-lang.org/reference/macros-by-example.html"
  },
  {
    "id": "macro-007",
    "category": "macros",
    "difficulty": 3,
    "type": "will_compile",
    "code": "macro_rules! debug {\n    ($val:expr) => {\n        println!(\"{} = {:?}\", stringify!($val), $val);\n    };\n}\n\nfn main() {\n    let x = 5;\n    debug!(x);\n    debug!(x + 10);\n}",
    "question": "What happens?",
    "options": [
      "Prints: x = 5 and x + 10 = 15",
      "Compile error: can't stringify expressions",
      "Prints: 5 = 5 and 15 = 15",
      "Compile error: duplicate macro invocation"
    ],
    "correct": 0,
    "explanation": "stringify! converts the tokens to a string, preserving the original expression text. Both invocations work correctly.",
    "rust_book_link": "https://doc.rust-lang.org/std/macro.stringify.html"
  },
  {
    "id": "macro-008",
    "category": "macros",
    "difficulty": 4,
    "type": "fix_code",
    "code": "macro_rules! hashmap {\n    ($($key:expr => $val:expr),*) => {{\n        let mut map = HashMap::new();\n        $( map.insert($key, $val); )*\n        map\n    }};\n}",
    "question": "What's missing for this to compile?",
    "options": [
      "use std::collections::HashMap; before the macro",
      "Nothing, macros don't need imports",
      "#[macro_use] attribute",
      "pub modifier on macro_rules"
    ],
    "correct": 0,
    "explanation": "The macro code is expanded in the caller's scope, which needs HashMap in scope. Macros can't provide imports.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch19-06-macros.html"
  },
  {
    "id": "macro-009",
    "category": "macros",
    "difficulty": 5,
    "type": "spot_error",
    "code": "macro_rules! count {\n    () => { 0 };\n    ($x:tt $($xs:tt)*) => { 1 + count!($($xs)*) };\n}\n\nfn main() {\n    let n = count!(a b c d);\n    println!(\"{}\", n);\n}",
    "question": "Is there an issue with this recursive macro?",
    "options": [
      "No, it correctly counts tokens as 4",
      "Yes, infinite recursion",
      "Yes, tt fragment can't be used this way",
      "Yes, arithmetic in macros is not allowed"
    ],
    "correct": 0,
    "explanation": "This is a valid recursive macro pattern. tt (token tree) matches any single token, enabling counting.",
    "rust_book_link": "https://doc.rust-lang.org/reference/macros-by-example.html"
  },
  {
    "id": "macro-010",
    "category": "macros",
    "difficulty": 3,
    "type": "predict_output",
    "code": "macro_rules! test {\n    ($val:expr) => {\n        println!(\"Expression: {}\", $val);\n    };\n    ($val:tt) => {\n        println!(\"Token: {}\", stringify!($val));\n    };\n}\n\nfn main() {\n    test!(5 + 5);\n}",
    "question": "Which arm matches?",
    "options": [
      "First arm (expr) - expressions are tried before token trees",
      "Second arm (tt)",
      "Both arms match, compilation error",
      "Neither, error"
    ],
    "correct": 0,
    "explanation": "Macro arms are tried in order. expr matches valid expressions, so the first arm matches before reaching tt.",
    "rust_book_link": "https://doc.rust-lang.org/reference/macros-by-example.html"
  },
  {
    "id": "unsafe-001",
    "category": "unsafe",
    "difficulty": 4,
    "type": "spot_error",
    "code": "fn main() {\n    let x = 5;\n    let ptr = &x as *const i32;\n    unsafe {\n        let val = *ptr;\n        println!(\"{}\", val);\n    }\n    drop(x);\n}",
    "question": "What's the problem?",
    "options": [
      "drop(x) is wrong - x is Copy type, can't be dropped explicitly",
      "Dereferencing ptr is undefined behavior",
      "Can't create raw pointer from reference",
      "Nothing, this is safe"
    ],
    "correct": 0,
    "explanation": "i32 implements Copy, so drop(x) doesn't compile. The pointer dereference is actually safe here since x is still valid.",
    "error_line": 8,
    "rust_book_link": "https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html"
  },
  {
    "id": "unsafe-002",
    "category": "unsafe",
    "difficulty": 5,
    "type": "will_compile",
    "code": "use std::ptr;\n\nfn main() {\n    let mut x = 10;\n    let ptr = &mut x as *mut i32;\n    \n    unsafe {\n        ptr::write(ptr, 20);\n    }\n    \n    println!(\"{}\", x);\n}",
    "question": "Will this compile and what does it print?",
    "options": [
      "Yes, prints 20 - ptr::write overwrites the value",
      "No, ptr::write requires ownership",
      "Yes, prints 10 - write doesn't affect x",
      "No, can't convert &mut to *mut"
    ],
    "correct": 0,
    "explanation": "ptr::write overwrites the memory at the pointer location without dropping the old value. Prints 20.",
    "rust_book_link": "https://doc.rust-lang.org/std/ptr/fn.write.html"
  },
  {
    "id": "unsafe-003",
    "category": "unsafe",
    "difficulty": 5,
    "type": "spot_error",
    "code": "fn main() {\n    let mut data = vec![1, 2, 3];\n    let ptr = data.as_mut_ptr();\n    \n    data.push(4);\n    \n    unsafe {\n        *ptr = 10;\n    }\n}",
    "question": "What's the undefined behavior?",
    "options": [
      "push() may reallocate, invalidating ptr",
      "Can't get mut pointer from Vec",
      "Writing through ptr after push is always safe",
      "as_mut_ptr() requires unsafe"
    ],
    "correct": 0,
    "explanation": "push() can trigger reallocation, making ptr a dangling pointer. Writing to it is undefined behavior.",
    "error_line": 7,
    "rust_book_link": "https://doc.rust-lang.org/nomicon/vec/vec.html"
  },
  {
    "id": "unsafe-004",
    "category": "unsafe",
    "difficulty": 4,
    "type": "idiomatic",
    "code": "// Which is safer?",
    "question": "To read from a raw pointer:",
    "options": [
      "ptr::read(ptr) - handles unaligned/uninitialized better",
      "*ptr - simpler and equivalent",
      "ptr.read() - method syntax is clearer",
      "All equally safe in unsafe blocks"
    ],
    "correct": 0,
    "explanation": "ptr::read() is more flexible for unaligned/packed data and makes intent clearer. Simple deref assumes aligned access.",
    "rust_book_link": "https://doc.rust-lang.org/std/ptr/fn.read.html"
  },
  {
    "id": "unsafe-005",
    "category": "unsafe",
    "difficulty": 5,
    "type": "fix_code",
    "code": "struct Node {\n    value: i32,\n    next: *mut Node,\n}\n\nfn traverse(mut ptr: *mut Node) {\n    unsafe {\n        while !ptr.is_null() {\n            println!(\"{}\", (*ptr).value);\n            ptr = (*ptr).next;\n        }\n    }\n}",
    "question": "What critical check is missing?",
    "options": [
      "Nothing - is_null() check is sufficient for this use",
      "Need to check if ptr is aligned",
      "Need to verify ptr points to valid memory",
      "Need to check for cycles"
    ],
    "correct": 2,
    "explanation": "is_null() only checks for null. The pointer could be invalid/dangling. Real code needs validity guarantees from construction.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html"
  },
  {
    "id": "unsafe-006",
    "category": "unsafe",
    "difficulty": 3,
    "type": "will_compile",
    "code": "fn main() {\n    let x = 42;\n    let ptr = &x as *const i32 as *mut i32;\n    \n    unsafe {\n        *ptr = 100;\n    }\n}",
    "question": "What happens?",
    "options": [
      "Undefined behavior - const to mut cast doesn't grant write permission",
      "Compiles and sets x to 100",
      "Compile error - can't cast const to mut",
      "Compiles but runtime error"
    ],
    "correct": 0,
    "explanation": "Casting *const to *mut compiles but doesn't make the data mutable. Writing through it is UB since x is immutable.",
    "error_line": 5,
    "rust_book_link": "https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html"
  },
  {
    "id": "unsafe-007",
    "category": "unsafe",
    "difficulty": 4,
    "type": "predict_output",
    "code": "use std::mem;\n\nfn main() {\n    let x: i32 = 42;\n    let y: f32 = unsafe { mem::transmute(x) };\n    println!(\"{}\", y);\n}",
    "question": "What does this print?",
    "options": [
      "5.88e-44 (bit pattern of 42 reinterpreted as f32)",
      "42.0",
      "Compile error: incompatible types",
      "Undefined behavior"
    ],
    "correct": 0,
    "explanation": "transmute reinterprets the bit pattern without conversion. 42 as bits represents a very small float.",
    "rust_book_link": "https://doc.rust-lang.org/std/mem/fn.transmute.html"
  },
  {
    "id": "unsafe-008",
    "category": "unsafe",
    "difficulty": 5,
    "type": "spot_error",
    "code": "fn extend_lifetime<'a, 'b>(r: &'a str) -> &'b str {\n    unsafe { std::mem::transmute(r) }\n}",
    "question": "Why is this dangerous?",
    "options": [
      "Allows returning reference that outlives the source data",
      "transmute can't change lifetimes",
      "Compile error: lifetime mismatch",
      "Not dangerous, just unnecessary"
    ],
    "correct": 0,
    "explanation": "This is a classic lifetime hole. Caller could get reference outliving the data, causing use-after-free.",
    "rust_book_link": "https://doc.rust-lang.org/nomicon/transmutes.html"
  },
  {
    "id": "unsafe-009",
    "category": "unsafe",
    "difficulty": 4,
    "type": "idiomatic",
    "code": "// Accessing union fields",
    "question": "Which is correct for reading union fields?",
    "options": [
      "Always requires unsafe block",
      "Safe if union implements Copy",
      "Safe for repr(C) unions",
      "Safe if field is actively set"
    ],
    "correct": 0,
    "explanation": "All union field access requires unsafe because you might read uninitialized memory or violate type invariants.",
    "rust_book_link": "https://doc.rust-lang.org/reference/items/unions.html"
  },
  {
    "id": "unsafe-010",
    "category": "unsafe",
    "difficulty": 5,
    "type": "will_compile",
    "code": "use std::slice;\n\nfn main() {\n    let arr = [1, 2, 3, 4, 5];\n    let ptr = arr.as_ptr();\n    \n    let s = unsafe { slice::from_raw_parts(ptr, 10) };\n    println!(\"{:?}\", s);\n}",
    "question": "What's wrong?",
    "options": [
      "Length 10 exceeds array bounds - undefined behavior",
      "Can't create slice from array pointer",
      "from_raw_parts requires mut pointer",
      "Nothing, it pads with zeros"
    ],
    "correct": 0,
    "explanation": "from_raw_parts doesn't validate length. Reading beyond bounds is UB. Must ensure [ptr, ptr+len) is valid.",
    "error_line": 7,
    "rust_book_link": "https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html"
  },
  {
    "id": "own-007",
    "category": "ownership",
    "difficulty": 3,
    "type": "spot_error",
    "code": "fn main() {\n    let s = String::from(\"hello\");\n    let r1 = &s;\n    let r2 = &s;\n    println!(\"{} and {}\", r1, r2);\n    let r3 = &mut s;\n    println!(\"{}\", r3);\n}",
    "question": "What's the problem?",
    "options": [
      "Can't take mutable reference while immutable refs are in scope",
      "Too many immutable references",
      "s needs to be mutable",
      "Nothing wrong"
    ],
    "correct": 0,
    "explanation": "r1 and r2's lifetimes extend past the mutable borrow attempt. Can't have &mut while & exists.",
    "error_line": 6,
    "rust_book_link": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html"
  },
  {
    "id": "own-008",
    "category": "ownership",
    "difficulty": 4,
    "type": "will_compile",
    "code": "fn main() {\n    let mut s = String::from(\"hello\");\n    let r1 = &s;\n    println!(\"{}\", r1);\n    let r2 = &mut s;\n    r2.push_str(\" world\");\n    println!(\"{}\", r2);\n}",
    "question": "Will this compile?",
    "options": [
      "Yes - r1's lifetime ends before r2 is created (NLL)",
      "No - can't have immutable then mutable ref",
      "No - s must be mut from the start",
      "Yes - but only in Rust 2021 edition"
    ],
    "correct": 0,
    "explanation": "Non-Lexical Lifetimes (NLL) end r1's lifetime after its last use, allowing r2 to borrow mutably.",
    "rust_book_link": "https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/non-lexical-lifetimes.html"
  },
  {
    "id": "own-009",
    "category": "ownership",
    "difficulty": 4,
    "type": "fix_code",
    "code": "struct Person {\n    name: String,\n}\n\nimpl Person {\n    fn get_name(&self) -> String {\n        self.name\n    }\n}",
    "question": "How to fix the ownership issue?",
    "options": [
      "Return &str or clone: self.name.clone() or &self.name",
      "Use move: move self.name",
      "Add &: &self.name",
      "Change to: *self.name"
    ],
    "correct": 0,
    "explanation": "Can't move out of borrowed self. Either clone the String or return a reference &String or &str.",
    "error_line": 7,
    "rust_book_link": "https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html"
  },
  {
    "id": "own-010",
    "category": "ownership",
    "difficulty": 3,
    "type": "predict_output",
    "code": "fn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1.clone();\n    println!(\"{}\", s1);\n}",
    "question": "What happens?",
    "options": [
      "Prints 'hello' - clone creates deep copy",
      "Compile error - s1 was moved",
      "Prints empty string",
      "Runtime error"
    ],
    "correct": 0,
    "explanation": "clone() creates a deep copy, so both s1 and s2 are valid separate String instances.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#variables-and-data-interacting-with-clone"
  },
  {
    "id": "own-011",
    "category": "ownership",
    "difficulty": 5,
    "type": "spot_error",
    "code": "fn main() {\n    let mut v = vec![1, 2, 3];\n    for i in &v {\n        v.push(*i + 1);\n    }\n}",
    "question": "Why does this fail?",
    "options": [
      "Immutable iteration borrow conflicts with mutable push",
      "Can't modify vector during iteration ever",
      "Need to deref i differently",
      "for doesn't create references"
    ],
    "correct": 0,
    "explanation": "The for loop borrows v immutably, preventing the mutable borrow needed by push(). Classic iterator invalidation prevention.",
    "error_line": 4,
    "rust_book_link": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html"
  },
  {
    "id": "own-012",
    "category": "ownership",
    "difficulty": 4,
    "type": "idiomatic",
    "code": "fn process(data: &Vec<i32>) -> i32 {\n    data.iter().sum()\n}",
    "question": "Better signature?",
    "options": [
      "fn process(data: &[i32]) - more flexible slice parameter",
      "fn process(data: Vec<i32>) - takes ownership",
      "fn process(data: &mut Vec<i32>) - allows modification",
      "Current signature is best"
    ],
    "correct": 0,
    "explanation": "&[i32] accepts Vec, arrays, and slices via deref coercion. More flexible than &Vec<T>.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch15-02-deref.html"
  },
  {
    "id": "own-013",
    "category": "ownership",
    "difficulty": 3,
    "type": "will_compile",
    "code": "fn first_word(s: &String) -> &str {\n    let bytes = s.as_bytes();\n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return &s[0..i];\n        }\n    }\n    &s[..]\n}",
    "question": "Is this safe?",
    "options": [
      "Yes - slice borrows from s, lifetime is valid",
      "No - slice lifetime doesn't match s",
      "No - can't return reference to local",
      "No - as_bytes() borrows mutably"
    ],
    "correct": 0,
    "explanation": "The slice &s[..] borrows from the input String, so the lifetime is correctly tied to the parameter.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch04-03-slices.html"
  },
  {
    "id": "own-014",
    "category": "ownership",
    "difficulty": 5,
    "type": "spot_error",
    "code": "fn main() {\n    let mut x = Box::new(5);\n    let y = &mut x;\n    let z = &mut x;\n    **y += 1;\n    **z += 1;\n}",
    "question": "What's wrong?",
    "options": [
      "Multiple mutable borrows of x",
      "Can't double-deref Box",
      "Box doesn't support +=",
      "Nothing, NLL fixes this"
    ],
    "correct": 0,
    "explanation": "Can't have two simultaneous mutable borrows. Both y and z's lifetimes overlap when they're used.",
    "error_line": 4,
    "rust_book_link": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html"
  },
  {
    "id": "own-015",
    "category": "ownership",
    "difficulty": 4,
    "type": "predict_output",
    "code": "fn take_ownership(s: String) {\n    println!(\"{}\", s);\n}\n\nfn main() {\n    let s = String::from(\"hello\");\n    take_ownership(s.clone());\n    println!(\"{}\", s);\n}",
    "question": "What happens?",
    "options": [
      "Prints 'hello' twice - clone preserves original",
      "Compile error after first print",
      "Prints 'hello' then empty string",
      "Compile error: can't clone String"
    ],
    "correct": 0,
    "explanation": "s.clone() creates a new String that's moved into the function. Original s remains valid.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html"
  },
  {
    "id": "async-004",
    "category": "async_await",
    "difficulty": 4,
    "type": "spot_error",
    "code": "#[tokio::main]\nasync fn main() {\n    let data = fetch_data();\n    println!(\"Got: {:?}\", data);\n}\n\nasync fn fetch_data() -> String {\n    \"data\".to_string()\n}",
    "question": "What's wrong?",
    "options": [
      "Missing .await on fetch_data() - it returns a Future",
      "fetch_data needs tokio::spawn",
      "async fn can't return String",
      "println! can't be used in async"
    ],
    "correct": 0,
    "explanation": "async fn returns a Future that must be .awaited. Without .await, data is a Future<String>, not String.",
    "error_line": 3,
    "rust_book_link": "https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html"
  },
  {
    "id": "async-005",
    "category": "async_await",
    "difficulty": 5,
    "type": "will_compile",
    "code": "#[tokio::main]\nasync fn main() {\n    let handle1 = tokio::spawn(async { 1 });\n    let handle2 = tokio::spawn(async { 2 });\n    let result = handle1.await.unwrap() + handle2.await.unwrap();\n    println!(\"{}\", result);\n}",
    "question": "What's the problem?",
    "options": [
      "None - this correctly spawns tasks and awaits them",
      "Can't await handle1 and handle2 sequentially",
      "spawn requires Send bound",
      "Can't add JoinHandle results"
    ],
    "correct": 0,
    "explanation": "This is valid. tokio::spawn returns JoinHandle which is awaitable. The tasks run concurrently, awaits are sequential.",
    "rust_book_link": "https://tokio.rs/tokio/tutorial/spawning"
  },
  {
    "id": "async-006",
    "category": "async_await",
    "difficulty": 4,
    "type": "fix_code",
    "code": "async fn process(items: Vec<i32>) -> Vec<i32> {\n    items.into_iter().map(|x| async {\n        expensive_computation(x).await\n    }).collect()\n}\n\nasync fn expensive_computation(x: i32) -> i32 {\n    x * 2\n}",
    "question": "What's the type error?",
    "options": [
      "Returns Vec<impl Future>, need futures::future::join_all",
      "Can't use async in map",
      "into_iter() doesn't work with async",
      "collect() doesn't support async"
    ],
    "correct": 0,
    "explanation": "map() creates an iterator of Futures, not awaited values. Use join_all or similar to await them concurrently.",
    "rust_book_link": "https://rust-lang.github.io/async-book/06_multiple_futures/02_join.html"
  },
  {
    "id": "async-007",
    "category": "async_await",
    "difficulty": 3,
    "type": "predict_output",
    "code": "#[tokio::main]\nasync fn main() {\n    let f1 = async { println!(\"1\"); };\n    let f2 = async { println!(\"2\"); };\n    println!(\"3\");\n}",
    "question": "What prints?",
    "options": [
      "Only '3' - futures are never awaited",
      "'1', '2', '3'",
      "'3', '1', '2'",
      "Compile error"
    ],
    "correct": 0,
    "explanation": "Futures are lazy. Without .await, f1 and f2 are never executed. Only '3' prints.",
    "rust_book_link": "https://rust-lang.github.io/async-book/02_execution/01_chapter.html"
  },
  {
    "id": "async-008",
    "category": "async_await",
    "difficulty": 5,
    "type": "spot_error",
    "code": "use std::rc::Rc;\n\n#[tokio::main]\nasync fn main() {\n    let data = Rc::new(vec![1, 2, 3]);\n    tokio::spawn(async move {\n        println!(\"{:?}\", data);\n    });\n}",
    "question": "What's the issue?",
    "options": [
      "Rc is not Send - can't be sent across threads",
      "Rc doesn't work with async",
      "Need Arc instead of Rc - wait, that's the same issue",
      "spawn requires 'static not move"
    ],
    "correct": 0,
    "explanation": "tokio::spawn requires Send. Rc is not Send (not thread-safe). Use Arc for shared ownership across tasks.",
    "error_line": 6,
    "rust_book_link": "https://tokio.rs/tokio/tutorial/spawning"
  },
  {
    "id": "async-009",
    "category": "async_await",
    "difficulty": 4,
    "type": "idiomatic",
    "code": "// Which is better for running multiple independent async operations?",
    "question": "To run 3 futures concurrently:",
    "options": [
      "tokio::join!(fut1, fut2, fut3) - concurrent execution",
      "fut1.await; fut2.await; fut3.await; - sequential",
      "Both are equivalent in performance",
      "Use futures::join_all instead"
    ],
    "correct": 0,
    "explanation": "tokio::join! runs futures concurrently and waits for all. Sequential awaits wait for each to complete before starting next.",
    "rust_book_link": "https://tokio.rs/tokio/tutorial/select#tokiojoin"
  },
  {
    "id": "async-010",
    "category": "async_await",
    "difficulty": 5,
    "type": "will_compile",
    "code": "async fn process() -> Result<i32, String> {\n    Ok(42)\n}\n\n#[tokio::main]\nasync fn main() {\n    let result = process().await?;\n    println!(\"{}\", result);\n}",
    "question": "Will this compile?",
    "options": [
      "No - main must return Result to use ?",
      "Yes - async main supports ?",
      "No - ? doesn't work with async",
      "Yes - tokio::main wraps errors"
    ],
    "correct": 0,
    "explanation": "? operator requires the function to return Result. main needs: async fn main() -> Result<(), Box<dyn Error>>",
    "error_line": 7,
    "rust_book_link": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html"
  },
  {
    "id": "async-011",
    "category": "async_await",
    "difficulty": 4,
    "type": "predict_output",
    "code": "use tokio::time::{sleep, Duration};\n\n#[tokio::main]\nasync fn main() {\n    let handle = tokio::spawn(async {\n        sleep(Duration::from_secs(1)).await;\n        println!(\"Task done\");\n    });\n    println!(\"Main done\");\n}",
    "question": "What happens?",
    "options": [
      "Prints 'Main done' immediately, may not print 'Task done'",
      "Waits 1 second, prints both",
      "Prints 'Task done' then 'Main done'",
      "Compile error"
    ],
    "correct": 0,
    "explanation": "spawn() doesn't block. Main exits immediately without awaiting the handle, possibly killing the task before it completes.",
    "rust_book_link": "https://tokio.rs/tokio/tutorial/spawning"
  },
  {
    "id": "async-012",
    "category": "async_await",
    "difficulty": 3,
    "type": "fix_code",
    "code": "async fn fetch_user(id: i32) -> User {\n    // fetch user\n}\n\nfn process_user(user: User) {\n    // process\n}\n\nasync fn main() {\n    let user = fetch_user(1);\n    process_user(user);\n}",
    "question": "How to fix?",
    "options": [
      "Add .await: let user = fetch_user(1).await;",
      "Make process_user async",
      "Remove async from fetch_user",
      "Use tokio::spawn"
    ],
    "correct": 0,
    "explanation": "fetch_user returns Future<User>, not User. Need .await to get the actual User value.",
    "error_line": 10,
    "rust_book_link": "https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html"
  },
  {
    "id": "async-013",
    "category": "async_await",
    "difficulty": 5,
    "type": "spot_error",
    "code": "use tokio::sync::Mutex;\n\nasync fn increment(counter: &Mutex<i32>) {\n    let mut num = counter.lock().await;\n    *num += 1;\n}",
    "question": "Is there an issue?",
    "options": [
      "No - this correctly uses async Mutex",
      "Yes - should use std::sync::Mutex",
      "Yes - lock() doesn't return await-able future",
      "Yes - can't borrow counter across await"
    ],
    "correct": 0,
    "explanation": "This is correct async Mutex usage. tokio::sync::Mutex::lock() is async and returns a guard that works across await points.",
    "rust_book_link": "https://tokio.rs/tokio/tutorial/shared-state"
  },
  {
    "id": "macro-011",
    "category": "macros",
    "difficulty": 4,
    "type": "will_compile",
    "code": "macro_rules! create_struct {\n    ($name:ident { $($field:ident: $type:ty),* }) => {\n        struct $name {\n            $($field: $type),*\n        }\n    };\n}\n\ncreate_struct!(Point { x: i32, y: i32 });",
    "question": "Does this compile?",
    "options": [
      "Yes - creates struct Point { x: i32, y: i32 }",
      "No - can't use ident for field names",
      "No - struct creation requires unsafe",
      "No - missing pub keyword"
    ],
    "correct": 0,
    "explanation": "This is a valid declarative macro pattern for generating struct definitions. ident matches identifiers perfectly for field names.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch19-06-macros.html"
  },
  {
    "id": "macro-012",
    "category": "macros",
    "difficulty": 5,
    "type": "spot_error",
    "code": "macro_rules! make_array {\n    ($val:expr; $count:expr) => {{\n        let mut arr = Vec::new();\n        for _ in 0..$count {\n            arr.push($val);\n        }\n        arr\n    }};\n}\n\nfn main() {\n    let x = String::from(\"hi\");\n    let arr = make_array!(x; 3);\n}",
    "question": "What's wrong?",
    "options": [
      "$val is moved in first iteration, subsequent pushes fail",
      "Can't use expr in for loop",
      "$count must be const",
      "Nothing, this works fine"
    ],
    "correct": 0,
    "explanation": "String doesn't implement Copy. First push moves x, making it unavailable for subsequent iterations. Need to clone or take different approach.",
    "error_line": 5,
    "rust_book_link": "https://doc.rust-lang.org/book/ch19-06-macros.html"
  },
  {
    "id": "macro-013",
    "category": "macros",
    "difficulty": 3,
    "type": "idiomatic",
    "code": "// Best practice for error handling in macros",
    "question": "Which macro pattern is most maintainable?",
    "options": [
      "Return Result and let caller handle with ?",
      "Use panic! for all errors",
      "Use unwrap() internally",
      "Macros shouldn't do error handling"
    ],
    "correct": 0,
    "explanation": "Returning Result follows Rust conventions and gives callers control over error handling. Panicking limits flexibility.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch09-00-error-handling.html"
  },
  {
    "id": "macro-014",
    "category": "macros",
    "difficulty": 4,
    "type": "predict_output",
    "code": "macro_rules! log {\n    ($msg:expr) => {\n        println!(\"[LOG] {}\", $msg);\n    };\n    ($msg:expr, $($arg:tt)*) => {\n        println!(\"[LOG] {}\", format!($msg, $($arg)*));\n    };\n}\n\nfn main() {\n    log!(\"Count: {}\", 5);\n}",
    "question": "What prints?",
    "options": [
      "[LOG] Count: 5",
      "Compile error: ambiguous macro",
      "[LOG] Count: {}",
      "[LOG] 5"
    ],
    "correct": 0,
    "explanation": "The second arm matches (expr with additional tokens). format! creates the string, which is then printed.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch19-06-macros.html"
  },
  {
    "id": "macro-015",
    "category": "macros",
    "difficulty": 5,
    "type": "fix_code",
    "code": "macro_rules! impl_trait {\n    ($type:ty, $trait:ident, $method:ident, $body:expr) => {\n        impl $trait for $type {\n            fn $method(&self) {\n                $body\n            }\n        }\n    };\n}",
    "question": "What limitation does this have?",
    "options": [
      "Can't handle generic traits or complex method signatures",
      "Can't use ident for trait names",
      "impl in macros requires unsafe",
      "Nothing, it's complete"
    ],
    "correct": 0,
    "explanation": "This simple macro can't handle traits with type parameters, associated types, or methods with different signatures. Real trait impls need more flexibility.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch19-06-macros.html"
  },
  {
    "id": "smart-001",
    "category": "traits_generics",
    "difficulty": 3,
    "type": "spot_error",
    "code": "fn main() {\n    let x = Box::new(5);\n    let y = x;\n    println!(\"{}\", x);\n}",
    "question": "What's wrong?",
    "options": [
      "Box was moved to y, can't use x anymore",
      "Box can't be printed",
      "Need to dereference x",
      "Nothing wrong"
    ],
    "correct": 0,
    "explanation": "Box<T> doesn't implement Copy. Assignment moves ownership to y, making x invalid.",
    "error_line": 4,
    "tags": [
      "smart_pointers",
      "box"
    ]
  },
  {
    "id": "smart-002",
    "category": "traits_generics",
    "difficulty": 4,
    "type": "idiomatic",
    "code": "// When to use Box<T>?",
    "question": "Best use case for Box<T>:",
    "options": [
      "Recursive types, trait objects, heap allocation",
      "Reference counting",
      "Thread-safe sharing",
      "Interior mutability"
    ],
    "correct": 0,
    "explanation": "Box provides heap allocation, enables recursive types (like linked lists), and stores trait objects. Use Rc for ref counting, Arc for threads.",
    "tags": [
      "smart_pointers",
      "box"
    ]
  },
  {
    "id": "smart-003",
    "category": "traits_generics",
    "difficulty": 5,
    "type": "will_compile",
    "code": "use std::rc::Rc;\n\nfn main() {\n    let x = Rc::new(5);\n    let y = Rc::clone(&x);\n    println!(\"{} {}\", Rc::strong_count(&x), *y);\n}",
    "question": "What does this print?",
    "options": [
      "2 5 - strong_count is 2, dereferenced value is 5",
      "1 5",
      "Compile error",
      "2 (memory address)"
    ],
    "correct": 0,
    "explanation": "Rc::clone increases the reference count without copying data. Two Rc pointers, strong_count is 2.",
    "tags": [
      "smart_pointers",
      "rc"
    ]
  },
  {
    "id": "smart-004",
    "category": "traits_generics",
    "difficulty": 4,
    "type": "spot_error",
    "code": "use std::rc::Rc;\nuse std::thread;\n\nfn main() {\n    let data = Rc::new(vec![1, 2, 3]);\n    \n    thread::spawn(move || {\n        println!(\"{:?}\", data);\n    });\n}",
    "question": "Why does this fail?",
    "options": [
      "Rc is not Send - can't cross thread boundaries",
      "Rc doesn't work with vectors",
      "thread::spawn requires Box",
      "move doesn't work with Rc"
    ],
    "correct": 0,
    "explanation": "Rc uses non-atomic reference counting, unsafe across threads. Use Arc (atomic Rc) for thread-safe sharing.",
    "error_line": 7,
    "tags": [
      "smart_pointers",
      "rc",
      "threading"
    ]
  },
  {
    "id": "smart-005",
    "category": "traits_generics",
    "difficulty": 5,
    "type": "fix_code",
    "code": "use std::rc::Rc;\n\nstruct Node {\n    value: i32,\n    next: Option<Rc<Node>>,\n}\n\nfn append(node: &mut Node, new_node: Node) {\n    node.next = Some(Rc::new(new_node));\n}",
    "question": "How to make this mutable linked list work?",
    "options": [
      "Use Rc<RefCell<Node>> for interior mutability",
      "Use Arc instead of Rc",
      "Make next field mutable",
      "This already works"
    ],
    "correct": 0,
    "explanation": "Rc provides shared ownership but not mutability. RefCell enables interior mutability, allowing mutation through shared references.",
    "tags": [
      "smart_pointers",
      "rc",
      "refcell"
    ]
  },
  {
    "id": "smart-006",
    "category": "traits_generics",
    "difficulty": 4,
    "type": "predict_output",
    "code": "use std::cell::RefCell;\n\nfn main() {\n    let data = RefCell::new(5);\n    *data.borrow_mut() += 10;\n    println!(\"{}\", data.borrow());\n}",
    "question": "What prints?",
    "options": [
      "15 - borrow_mut allows mutation",
      "5 - mutations don't persist",
      "Runtime panic - borrow conflict",
      "Compile error"
    ],
    "correct": 0,
    "explanation": "RefCell allows interior mutability. borrow_mut() provides mutable access, mutation persists after the borrow is dropped.",
    "tags": [
      "smart_pointers",
      "refcell"
    ]
  },
  {
    "id": "smart-007",
    "category": "traits_generics",
    "difficulty": 5,
    "type": "spot_error",
    "code": "use std::cell::RefCell;\n\nfn main() {\n    let data = RefCell::new(vec![1, 2, 3]);\n    let b1 = data.borrow();\n    let b2 = data.borrow_mut();\n    println!(\"{:?}\", b1);\n}",
    "question": "What happens?",
    "options": [
      "Runtime panic - can't borrow_mut while immutable borrow exists",
      "Compile error",
      "Prints [1, 2, 3]",
      "b2 blocks until b1 is dropped"
    ],
    "correct": 0,
    "explanation": "RefCell enforces borrowing rules at runtime. Having immutable and mutable borrows simultaneously causes panic.",
    "error_line": 6,
    "tags": [
      "smart_pointers",
      "refcell"
    ]
  },
  {
    "id": "smart-008",
    "category": "traits_generics",
    "difficulty": 3,
    "type": "idiomatic",
    "code": "// Choosing between Cell and RefCell",
    "question": "When to use Cell<T> vs RefCell<T>?",
    "options": [
      "Cell for Copy types, RefCell for non-Copy types needing references",
      "Cell for single-threaded, RefCell for multi-threaded",
      "Cell is deprecated, use RefCell",
      "They're interchangeable"
    ],
    "correct": 0,
    "explanation": "Cell works with Copy types via get/set. RefCell provides references via borrow/borrow_mut for non-Copy types.",
    "tags": [
      "smart_pointers",
      "cell",
      "refcell"
    ]
  },
  {
    "id": "smart-009",
    "category": "traits_generics",
    "difficulty": 5,
    "type": "will_compile",
    "code": "use std::rc::{Rc, Weak};\n\nstruct Node {\n    parent: Option<Weak<Node>>,\n    children: Vec<Rc<Node>>,\n}\n\nfn main() {\n    let child = Rc::new(Node {\n        parent: None,\n        children: vec![],\n    });\n}",
    "question": "Why use Weak for parent?",
    "options": [
      "Prevents reference cycles that would leak memory",
      "Weak is faster than Rc",
      "Parent doesn't need ownership",
      "Weak is required for Option"
    ],
    "correct": 0,
    "explanation": "Parent-child with Rc creates cycles. Weak doesn't contribute to ref count, preventing leaks when cycles exist.",
    "tags": [
      "smart_pointers",
      "rc",
      "weak"
    ]
  },
  {
    "id": "smart-010",
    "category": "traits_generics",
    "difficulty": 4,
    "type": "predict_output",
    "code": "use std::rc::{Rc, Weak};\n\nfn main() {\n    let strong = Rc::new(5);\n    let weak = Rc::downgrade(&strong);\n    drop(strong);\n    println!(\"{:?}\", weak.upgrade());\n}",
    "question": "What prints?",
    "options": [
      "None - strong was dropped, weak.upgrade() returns None",
      "Some(5)",
      "Runtime panic",
      "Compile error"
    ],
    "correct": 0,
    "explanation": "Weak doesn't keep data alive. After strong is dropped, upgrade() returns None since no strong references remain.",
    "tags": [
      "smart_pointers",
      "weak"
    ]
  },
  {
    "id": "smart-011",
    "category": "traits_generics",
    "difficulty": 4,
    "type": "spot_error",
    "code": "use std::sync::Arc;\nuse std::thread;\n\nfn main() {\n    let data = Arc::new(vec![1, 2, 3]);\n    let data_clone = Arc::clone(&data);\n    \n    thread::spawn(move || {\n        data_clone.push(4);\n    });\n}",
    "question": "Why does this fail?",
    "options": [
      "Arc provides shared ownership, not mutability",
      "Arc can't be cloned",
      "thread::spawn doesn't work with Arc",
      "push requires Rc not Arc"
    ],
    "correct": 0,
    "explanation": "Arc enables thread-safe sharing but not mutation. Need Arc<Mutex<Vec<i32>>> for shared mutable access.",
    "error_line": 9,
    "tags": [
      "smart_pointers",
      "arc"
    ]
  },
  {
    "id": "macro-016",
    "category": "macros",
    "difficulty": 4,
    "type": "spot_error",
    "code": "macro_rules! min {\n    ($x:expr) => ($x);\n    ($x:expr, $($y:expr),+) => {\n        std::cmp::min($x, min!($($y),+))\n    };\n}\n\nfn main() {\n    println!(\"{}\", min!(3, 1, 4, 1, 5));\n}",
    "question": "What does this print?",
    "options": [
      "1 - recursive macro finds minimum",
      "Compile error: infinite recursion",
      "3",
      "5"
    ],
    "correct": 0,
    "explanation": "This macro recursively compares elements using std::cmp::min, correctly finding the minimum value of 1.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch19-06-macros.html"
  },
  {
    "id": "macro-017",
    "category": "macros",
    "difficulty": 5,
    "type": "idiomatic",
    "code": "// Declarative vs procedural macros",
    "question": "When to use procedural macros over macro_rules?",
    "options": [
      "Custom derive, attribute macros, complex transformations",
      "Simple repetition and pattern matching",
      "Procedural macros are deprecated",
      "Always use macro_rules first"
    ],
    "correct": 0,
    "explanation": "Procedural macros (#[derive], #[attribute]) enable complex code generation impossible with declarative macros. Use macro_rules for simple patterns.",
    "rust_book_link": "https://doc.rust-lang.org/reference/procedural-macros.html"
  },
  {
    "id": "macro-018",
    "category": "macros",
    "difficulty": 4,
    "type": "will_compile",
    "code": "#[macro_export]\nmacro_rules! assert_eq_custom {\n    ($left:expr, $right:expr) => {{\n        match (&$left, &$right) {\n            (left_val, right_val) => {\n                if !(*left_val == *right_val) {\n                    panic!(\"assertion failed: {} == {}\", left_val, right_val);\n                }\n            }\n        }\n    }};\n}",
    "question": "Why use match with references?",
    "options": [
      "Prevents moving values, evaluates expressions once",
      "Required for comparison",
      "match is faster than if",
      "References are required for panic"
    ],
    "correct": 0,
    "explanation": "Using match with references evaluates expressions once and avoids moving non-Copy types. Standard pattern for assertion macros.",
    "rust_book_link": "https://doc.rust-lang.org/std/macro.assert_eq.html"
  },
  {
    "id": "macro-019",
    "category": "macros",
    "difficulty": 3,
    "type": "predict_output",
    "code": "macro_rules! print_type {\n    ($val:expr) => {{\n        println!(\"Type: {}\", std::any::type_name_of_val(&$val));\n    }};\n}\n\nfn main() {\n    print_type!(42);\n    print_type!(\"hello\");\n}",
    "question": "What does this print?",
    "options": [
      "Type: i32\\nType: &str",
      "Compile error: type_name_of_val doesn't exist",
      "Type: expr for both",
      "Runtime error"
    ],
    "correct": 0,
    "explanation": "type_name_of_val returns the type name as a string. Correctly prints the inferred types.",
    "rust_book_link": "https://doc.rust-lang.org/std/any/fn.type_name_of_val.html"
  },
  {
    "id": "macro-020",
    "category": "macros",
    "difficulty": 5,
    "type": "fix_code",
    "code": "macro_rules! impl_display {\n    ($type:ty, $fmt:expr) => {\n        impl std::fmt::Display for $type {\n            fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n                write!(f, $fmt, self)\n            }\n        }\n    };\n}",
    "question": "What's the limitation?",
    "options": [
      "Can't access struct fields, $fmt must use self as whole",
      "Can't implement Display via macros",
      "write! doesn't work in macros",
      "Nothing, this is complete"
    ],
    "correct": 0,
    "explanation": "This macro can only format self as a whole. Accessing fields requires more complex macro patterns or procedural macros.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch19-06-macros.html"
  },
  {
    "id": "unsafe-016",
    "category": "unsafe",
    "difficulty": 4,
    "type": "spot_error",
    "code": "fn get_unchecked_demo() {\n    let v = vec![1, 2, 3];\n    unsafe {\n        let x = v.get_unchecked(5);\n        println!(\"{}\", x);\n    }\n}",
    "question": "What's wrong?",
    "options": [
      "Index out of bounds - undefined behavior",
      "get_unchecked requires mut",
      "Can't print results from get_unchecked",
      "Nothing wrong"
    ],
    "correct": 0,
    "explanation": "get_unchecked skips bounds checking. Accessing index 5 in a 3-element vector is UB, likely causing a crash or reading garbage.",
    "error_line": 4
  },
  {
    "id": "unsafe-017",
    "category": "unsafe",
    "difficulty": 5,
    "type": "idiomatic",
    "code": "// Safe abstraction over unsafe code",
    "question": "Best practice for unsafe in libraries:",
    "options": [
      "Provide safe public API, keep unsafe internal and well-documented",
      "Mark entire module as unsafe",
      "Avoid unsafe completely",
      "Expose unsafe functions to give users control"
    ],
    "correct": 0,
    "explanation": "Encapsulate unsafe in safe abstractions. Maintain invariants internally, expose safe API. Document all safety requirements.",
    "rust_book_link": "https://doc.rust-lang.org/nomicon/safe-unsafe-meaning.html"
  },
  {
    "id": "unsafe-018",
    "category": "unsafe",
    "difficulty": 4,
    "type": "will_compile",
    "code": "use std::mem::MaybeUninit;\n\nfn main() {\n    let mut x = MaybeUninit::<i32>::uninit();\n    unsafe {\n        x.write(42);\n        println!(\"{}\", x.assume_init());\n    }\n}",
    "question": "Is this the correct pattern?",
    "options": [
      "Yes - write then assume_init is the standard MaybeUninit pattern",
      "No - assume_init is always unsafe",
      "No - need to use ptr::write instead",
      "No - MaybeUninit can't hold i32"
    ],
    "correct": 0,
    "explanation": "MaybeUninit is for working with uninitialized memory safely. write() initializes it, then assume_init() is safe to call.",
    "rust_book_link": "https://doc.rust-lang.org/std/mem/union.MaybeUninit.html"
  },
  {
    "id": "unsafe-019",
    "category": "unsafe",
    "difficulty": 5,
    "type": "predict_output",
    "code": "fn main() {\n    let x = 5;\n    let ptr = &x as *const i32 as usize;\n    let back = ptr as *const i32;\n    unsafe {\n        println!(\"{}\", *back);\n    }\n}",
    "question": "What happens?",
    "options": [
      "Likely prints 5, but technically relies on implementation details",
      "Always prints 5 safely",
      "Compile error - can't cast pointer to usize",
      "Undefined behavior"
    ],
    "correct": 0,
    "explanation": "Casting pointers to integers and back works in practice but is implementation-defined. Better to keep pointers as pointers.",
    "rust_book_link": "https://doc.rust-lang.org/std/primitive.pointer.html"
  },
  {
    "id": "unsafe-020",
    "category": "unsafe",
    "difficulty": 4,
    "type": "fix_code",
    "code": "unsafe fn dangerous() {\n    // Some unsafe operation\n}\n\nfn safe_wrapper() {\n    dangerous();\n}",
    "question": "What's missing?",
    "options": [
      "Need unsafe block to call unsafe function",
      "safe_wrapper must also be unsafe",
      "Nothing, this compiles",
      "dangerous() can't be called from safe code"
    ],
    "correct": 0,
    "explanation": "Calling unsafe functions requires an unsafe block, making the caller acknowledge the safety contract.",
    "error_line": 6,
    "rust_book_link": "https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html"
  },
  {
    "id": "own-016",
    "category": "ownership",
    "difficulty": 4,
    "type": "spot_error",
    "code": "fn process(data: &mut Vec<i32>) {\n    for item in data {\n        *item *= 2;\n    }\n}",
    "question": "What needs to change?",
    "options": [
      "Use data.iter_mut() instead of data",
      "Change to &Vec<i32>",
      "Add unsafe block",
      "Nothing wrong"
    ],
    "correct": 0,
    "explanation": "Iterating with 'for item in data' tries to move data. Use data.iter_mut() to get mutable references.",
    "error_line": 2
  },
  {
    "id": "own-017",
    "category": "ownership",
    "difficulty": 5,
    "type": "will_compile",
    "code": "struct Container {\n    data: Vec<i32>,\n}\n\nimpl Container {\n    fn get_data(self) -> Vec<i32> {\n        self.data\n    }\n}\n\nfn main() {\n    let c = Container { data: vec![1, 2, 3] };\n    let d = c.get_data();\n    println!(\"{:?}\", c.data);\n}",
    "question": "What's wrong?",
    "options": [
      "get_data consumes self, c is moved",
      "Can't return owned data",
      "data is private",
      "Nothing wrong"
    ],
    "correct": 0,
    "explanation": "Method takes self (not &self), consuming the Container. Can't use c afterward. Use &self and clone, or just move.",
    "error_line": 14
  },
  {
    "id": "own-018",
    "category": "ownership",
    "difficulty": 4,
    "type": "idiomatic",
    "code": "fn process_strings(v: Vec<String>) -> Vec<String> {\n    v.into_iter()\n        .map(|s| s.to_uppercase())\n        .collect()\n}",
    "question": "Is this efficient?",
    "options": [
      "Yes - into_iter() consumes vec, map transforms in place where possible",
      "No - should use iter() instead",
      "No - need to clone each string",
      "No - collect() always allocates"
    ],
    "correct": 0,
    "explanation": "into_iter() gives ownership of elements, avoiding clones. Map can transform in place. This is the idiomatic pattern.",
    "rust_book_link": "https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect"
  },
  {
    "id": "own-019",
    "category": "ownership",
    "difficulty": 5,
    "type": "predict_output",
    "code": "fn main() {\n    let mut x = Box::new(5);\n    let y = &mut x;\n    **y = 10;\n    let z = &mut x;\n    **z = 15;\n    println!(\"{}\", x);\n}",
    "question": "What happens?",
    "options": [
      "Prints 15 - y's lifetime ends before z, NLL allows this",
      "Compile error - two mutable borrows",
      "Prints 10",
      "Runtime panic"
    ],
    "correct": 0,
    "explanation": "Non-lexical lifetimes: y's lifetime ends after its last use. z can borrow mutably afterward. Final value is 15.",
    "rust_book_link": "https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/non-lexical-lifetimes.html"
  },
  {
    "id": "own-020",
    "category": "ownership",
    "difficulty": 4,
    "type": "fix_code",
    "code": "fn split_first(s: &String) -> (&str, &str) {\n    let mid = s.len() / 2;\n    (&s[..mid], &s[mid..])\n}",
    "question": "Better parameter type?",
    "options": [
      "Change to &str - more flexible, works with String, &str, literals",
      "Change to String - take ownership",
      "Add lifetime annotation",
      "Current is best"
    ],
    "correct": 0,
    "explanation": "&str is more flexible than &String. Accepts String (via deref), &str, and literals. Same functionality, better API.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch04-03-slices.html"
  },
  {
    "id": "async-014",
    "category": "async_await",
    "difficulty": 4,
    "type": "spot_error",
    "code": "use tokio::time::{sleep, Duration};\n\n#[tokio::main]\nasync fn main() {\n    let handles: Vec<_> = (0..5)\n        .map(|i| async move {\n            sleep(Duration::from_millis(100)).await;\n            i * 2\n        })\n        .collect();\n    \n    for h in handles {\n        println!(\"{}\", h.await);\n    }\n}",
    "question": "What's wrong?",
    "options": [
      "Need tokio::spawn to create tasks, or use join_all for futures",
      "async move doesn't work in map",
      "Can't await in for loop",
      "Nothing wrong"
    ],
    "correct": 0,
    "explanation": "map creates futures but doesn't run them. Need tokio::spawn (returns JoinHandle) or futures::future::join_all.",
    "error_line": 12
  },
  {
    "id": "async-015",
    "category": "async_await",
    "difficulty": 5,
    "type": "idiomatic",
    "code": "// Choosing between tokio::spawn and spawning on executor",
    "question": "When to use tokio::spawn vs task::spawn_local?",
    "options": [
      "spawn for Send futures, spawn_local for !Send (like Rc)",
      "spawn_local is always faster",
      "They're identical",
      "spawn_local is deprecated"
    ],
    "correct": 0,
    "explanation": "tokio::spawn requires Send. spawn_local allows !Send futures but must run on current thread. Use spawn for most cases.",
    "rust_book_link": "https://tokio.rs/tokio/tutorial/spawning"
  },
  {
    "id": "async-016",
    "category": "async_await",
    "difficulty": 4,
    "type": "will_compile",
    "code": "use tokio::select;\n\n#[tokio::main]\nasync fn main() {\n    let mut a = async { 1 };\n    let mut b = async { 2 };\n    \n    select! {\n        val = a => println!(\"a: {}\", val),\n        val = b => println!(\"b: {}\", val),\n    }\n}",
    "question": "What does select! do?",
    "options": [
      "Waits for first future to complete, cancels others",
      "Waits for all futures",
      "Runs futures in sequence",
      "Compile error"
    ],
    "correct": 0,
    "explanation": "select! polls multiple futures concurrently, proceeds with first to complete. Others are dropped/canceled.",
    "rust_book_link": "https://tokio.rs/tokio/tutorial/select"
  },
  {
    "id": "async-017",
    "category": "async_await",
    "difficulty": 5,
    "type": "predict_output",
    "code": "use tokio::sync::mpsc;\n\n#[tokio::main]\nasync fn main() {\n    let (tx, mut rx) = mpsc::channel(1);\n    \n    tokio::spawn(async move {\n        tx.send(\"hello\").await.unwrap();\n    });\n    \n    println!(\"{}\", rx.recv().await.unwrap());\n}",
    "question": "Does this work correctly?",
    "options": [
      "Yes - channel passes message from task to main",
      "No - channel capacity too small",
      "No - can't await in main",
      "No - spawn doesn't return the value"
    ],
    "correct": 0,
    "explanation": "This is the standard pattern for communication between tasks using channels. Works correctly with buffer size 1.",
    "rust_book_link": "https://tokio.rs/tokio/tutorial/channels"
  },
  {
    "id": "async-018",
    "category": "async_await",
    "difficulty": 4,
    "type": "fix_code",
    "code": "async fn process() -> Result<i32, std::io::Error> {\n    Ok(42)\n}\n\n#[tokio::main]\nasync fn main() {\n    let result = process().await.unwrap();\n    println!(\"{}\", result);\n}",
    "question": "More idiomatic error handling?",
    "options": [
      "Use ? operator and return Result from main",
      "Always use unwrap in async",
      "Use match instead",
      "Current is best"
    ],
    "correct": 0,
    "explanation": "Async main can return Result. Using ? is more idiomatic than unwrap for propagating errors.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html"
  },
  {
    "id": "smart-031",
    "category": "traits_generics",
    "difficulty": 5,
    "type": "spot_error",
    "code": "use std::sync::{Arc, Mutex};\n\nstruct Database {\n    data: Arc<Mutex<Vec<String>>>,\n}\n\nimpl Database {\n    fn add(&self, item: String) {\n        let mut data = self.data.lock().unwrap();\n        data.push(item);\n        drop(data);\n        self.process();\n    }\n    \n    fn process(&self) {\n        let data = self.data.lock().unwrap();\n        for item in data.iter() {\n            println!(\"{}\", item);\n        }\n    }\n}",
    "question": "Is the drop() necessary?",
    "options": [
      "No - guard is automatically dropped at end of scope",
      "Yes - prevents deadlock",
      "Yes - required for Mutex",
      "Yes - Rust doesn't have automatic drops"
    ],
    "correct": 0,
    "explanation": "MutexGuard implements Drop and releases the lock when it goes out of scope. Explicit drop() is redundant but doesn't hurt.",
    "rust_book_link": "https://doc.rust-lang.org/std/sync/struct.MutexGuard.html"
  },
  {
    "id": "smart-032",
    "category": "traits_generics",
    "difficulty": 4,
    "type": "idiomatic",
    "code": "use std::sync::Arc;\nuse std::sync::atomic::{AtomicBool, Ordering};\n\nstruct Flag {\n    inner: Arc<AtomicBool>,\n}",
    "question": "Why use AtomicBool over Mutex<bool>?",
    "options": [
      "Lock-free, faster for simple flags, no possibility of deadlock",
      "Required by Arc",
      "Mutex doesn't work with bool",
      "AtomicBool uses less memory"
    ],
    "correct": 0,
    "explanation": "Atomics provide lock-free synchronization. Better performance for simple types. Mutex is overkill for a bool flag.",
    "rust_book_link": "https://doc.rust-lang.org/std/sync/atomic/"
  },
  {
    "id": "smart-033",
    "category": "traits_generics",
    "difficulty": 5,
    "type": "will_compile",
    "code": "use std::pin::Pin;\n\nasync fn example(data: Pin<&mut Vec<i32>>) {\n    data.as_ref().get_ref()[0];\n}",
    "question": "What does Pin guarantee?",
    "options": [
      "Prevents moving the pinned value through safe code",
      "Makes the value immutable",
      "Requires unsafe to access",
      "Adds thread safety"
    ],
    "correct": 0,
    "explanation": "Pin prevents moving, crucial for self-referential types in async. The value can still be accessed but not moved.",
    "rust_book_link": "https://doc.rust-lang.org/std/pin/index.html"
  },
  {
    "id": "smart-034",
    "category": "traits_generics",
    "difficulty": 4,
    "type": "predict_output",
    "code": "use std::rc::Rc;\n\nfn main() {\n    let a = Rc::new(vec![1, 2, 3]);\n    let b = Rc::clone(&a);\n    \n    println!(\"{}\", Rc::ptr_eq(&a, &b));\n    \n    let c = Rc::new(vec![1, 2, 3]);\n    println!(\"{}\", Rc::ptr_eq(&a, &c));\n}",
    "question": "What prints?",
    "options": [
      "true false - a and b point to same allocation, c is different",
      "true true - all have same value",
      "false false",
      "Compile error"
    ],
    "correct": 0,
    "explanation": "ptr_eq compares pointer addresses, not values. Cloned Rc points to same allocation, new Rc is different.",
    "rust_book_link": "https://doc.rust-lang.org/std/rc/struct.Rc.html#method.ptr_eq"
  },
  {
    "id": "smart-035",
    "category": "traits_generics",
    "difficulty": 5,
    "type": "fix_code",
    "code": "use std::sync::{Arc, RwLock};\n\nfn update(data: Arc<RwLock<Vec<i32>>>, val: i32) {\n    let mut w = data.write().unwrap();\n    w.push(val);\n    let r = data.read().unwrap();\n    println!(\"{:?}\", r);\n}",
    "question": "What's the deadlock?",
    "options": [
      "Write lock held while trying to acquire read lock on same thread",
      "Can't have write and read locks",
      "Arc doesn't support multiple locks",
      "Nothing wrong"
    ],
    "correct": 0,
    "explanation": "RwLock deadlocks if same thread tries to acquire read while holding write. Drop write guard before reading.",
    "error_line": 6,
    "rust_book_link": "https://doc.rust-lang.org/std/sync/struct.RwLock.html"
  },
  {
    "id": "macro-021",
    "category": "macros",
    "difficulty": 5,
    "type": "spot_error",
    "code": "macro_rules! closure {\n    ($arg:ident, $body:expr) => {\n        |$arg| $body\n    };\n}\n\nfn main() {\n    let add_one = closure!(x, x + 1);\n    println!(\"{}\", add_one(5));\n}",
    "question": "What's the issue?",
    "options": [
      "Works but hygiene means inner x different from outer x contexts",
      "Can't create closures in macros",
      "$body must be block, not expr",
      "Nothing wrong"
    ],
    "correct": 0,
    "explanation": "Macro hygiene means identifiers from macro definition are separate from call site. This works but can be confusing.",
    "rust_book_link": "https://doc.rust-lang.org/reference/macros-by-example.html#hygiene"
  },
  {
    "id": "macro-022",
    "category": "macros",
    "difficulty": 4,
    "type": "will_compile",
    "code": "macro_rules! swap {\n    ($a:expr, $b:expr) => {{\n        let temp = $a;\n        $a = $b;\n        $b = temp;\n    }};\n}\n\nfn main() {\n    let mut x = 1;\n    let mut y = 2;\n    swap!(x, y);\n}",
    "question": "Does this work?",
    "options": [
      "No - can't assign to $a, expr can't be lvalue",
      "Yes - swaps values",
      "No - temp conflicts",
      "Yes but needs std::mem::swap"
    ],
    "correct": 0,
    "explanation": "expr fragment can't appear on left side of assignment. Would need to use std::mem::swap or pass as idents.",
    "error_line": 4
  },
  {
    "id": "macro-023",
    "category": "macros",
    "difficulty": 5,
    "type": "idiomatic",
    "code": "// Macro exporting best practices",
    "question": "Best practice for exporting macros from libraries?",
    "options": [
      "Use #[macro_export] and document in module-level docs",
      "Put macros in separate macro module",
      "Never export macros from libraries",
      "Always use procedural macros instead"
    ],
    "correct": 0,
    "explanation": "#[macro_export] makes macros available at crate root. Document safety requirements and provide usage examples.",
    "rust_book_link": "https://doc.rust-lang.org/reference/macros-by-example.html#the-macro_export-attribute"
  },
  {
    "id": "macro-024",
    "category": "macros",
    "difficulty": 4,
    "type": "predict_output",
    "code": "macro_rules! repeat {\n    ($e:expr; $n:expr) => {{\n        let mut v = Vec::new();\n        for _ in 0..$n {\n            v.push($e.clone());\n        }\n        v\n    }};\n}\n\nfn main() {\n    let v = repeat!(String::from(\"hi\"); 3);\n    println!(\"{}\", v.len());\n}",
    "question": "What prints?",
    "options": [
      "3 - creates 3 clones of the string",
      "Compile error - can't clone in macro",
      "1",
      "0"
    ],
    "correct": 0,
    "explanation": "The macro clones the expression for each iteration. Creates a vector with 3 String instances.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch19-06-macros.html"
  },
  {
    "id": "macro-025",
    "category": "macros",
    "difficulty": 5,
    "type": "fix_code",
    "code": "macro_rules! build_struct {\n    ($name:ident { $($field:ident: $ty:ty = $val:expr),* }) => {\n        struct $name {\n            $($field: $ty),*\n        }\n        \n        impl $name {\n            fn new() -> Self {\n                Self {\n                    $($field: $val),*\n                }\n            }\n        }\n    };\n}",
    "question": "What's a limitation?",
    "options": [
      "Can't generate different impls for different field types",
      "Can't create structs with macros",
      "impl blocks illegal in macros",
      "Nothing, this is complete"
    ],
    "correct": 0,
    "explanation": "This generates a basic constructor but can't customize per-field initialization or add custom methods. Complex logic needs procedural macros.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch19-06-macros.html"
  },
  {
    "id": "expert-001",
    "category": "traits_generics",
    "difficulty": 5,
    "type": "spot_error",
    "code": "trait MyTrait {\n    fn method(&self) -> impl Iterator<Item = i32>;\n}",
    "question": "Is this valid Rust?",
    "options": [
      "Yes in Rust 2021+ with RPITIT (return position impl trait in traits)",
      "No - can't use impl Trait in traits",
      "No - must use Box<dyn Iterator>",
      "Only with #[feature] gate"
    ],
    "correct": 0,
    "explanation": "Rust 1.75+ supports RPITIT, allowing impl Trait in trait method return types without boxing.",
    "rust_book_link": "https://blog.rust-lang.org/2023/12/21/async-fn-rpit-in-traits.html"
  },
  {
    "id": "expert-002",
    "category": "lifetimes",
    "difficulty": 5,
    "type": "fix_code",
    "code": "struct Parser<'a> {\n    data: &'a str,\n}\n\nimpl<'a> Parser<'a> {\n    fn parse(&self) -> Result<&str, Error> {\n        // parsing logic\n    }\n}",
    "question": "What's the lifetime issue in parse?",
    "options": [
      "Return type needs &'a str - tied to struct lifetime",
      "Need &'self str",
      "Result can't contain references",
      "Nothing wrong"
    ],
    "correct": 0,
    "explanation": "The returned &str should live as long as the Parser's data. Use &'a str to tie it to the struct's lifetime.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html"
  },
  {
    "id": "expert-003",
    "category": "unsafe",
    "difficulty": 5,
    "type": "will_compile",
    "code": "use std::mem::ManuallyDrop;\n\nfn main() {\n    let x = ManuallyDrop::new(String::from(\"hello\"));\n    // x is never dropped\n}",
    "question": "What's the purpose of ManuallyDrop?",
    "options": [
      "Prevents automatic drop, useful for FFI and manual memory management",
      "Required for all heap allocations",
      "Makes types Copy",
      "Only for unsafe code"
    ],
    "correct": 0,
    "explanation": "ManuallyDrop disables drop. Useful when interfacing with C, or custom drop order. Memory leak if not manually dropped.",
    "rust_book_link": "https://doc.rust-lang.org/std/mem/struct.ManuallyDrop.html"
  },
  {
    "id": "expert-004",
    "category": "macros",
    "difficulty": 5,
    "type": "predict_output",
    "code": "macro_rules! lazy_static {\n    ($name:ident : $ty:ty = $init:expr) => {\n        static $name: std::sync::OnceLock<$ty> = std::sync::OnceLock::new();\n        \n        impl $name {\n            fn get() -> &'static $ty {\n                $name.get_or_init(|| $init)\n            }\n        }\n    };\n}",
    "question": "What pattern does this implement?",
    "options": [
      "Lazy static initialization - value created on first access",
      "Eager initialization",
      "Compile error - can't impl on static",
      "Thread-local storage"
    ],
    "correct": 0,
    "explanation": "OnceLock enables lazy initialization of statics. Common pattern for expensive one-time setup.",
    "rust_book_link": "https://doc.rust-lang.org/std/sync/struct.OnceLock.html"
  },
  {
    "id": "expert-005",
    "category": "async_await",
    "difficulty": 5,
    "type": "spot_error",
    "code": "async fn foo() -> impl Future<Output = i32> {\n    async { 42 }\n}",
    "question": "Is this redundant?",
    "options": [
      "Yes - async fn already returns impl Future",
      "No - double wrapping is required",
      "No - different Future types",
      "Compile error"
    ],
    "correct": 0,
    "explanation": "async fn returns Future automatically. The inner async {} creates a nested Future. Should just return 42.",
    "rust_book_link": "https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html"
  },
  {
    "id": "expert-006",
    "category": "ownership",
    "difficulty": 5,
    "type": "idiomatic",
    "code": "// Interior vs exterior mutability",
    "question": "When to use Cell/RefCell over regular &mut?",
    "options": [
      "When you need mutation through shared (&) references",
      "Always prefer interior mutability",
      "Only in unsafe code",
      "They're equivalent to &mut"
    ],
    "correct": 0,
    "explanation": "Interior mutability trades compile-time for runtime borrow checking. Use when architecture requires mutation through & refs.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch15-05-interior-mutability.html"
  },
  {
    "id": "expert-007",
    "category": "traits_generics",
    "difficulty": 5,
    "type": "will_compile",
    "code": "trait Foo<T> {\n    type Output;\n    fn process(&self, input: T) -> Self::Output;\n}\n\nimpl Foo<i32> for String {\n    type Output = usize;\n    fn process(&self, input: i32) -> usize {\n        self.len() + input as usize\n    }\n}",
    "question": "What's the difference: generic param vs associated type?",
    "options": [
      "Generic param T allows multiple impls per type, associated type allows one",
      "They're identical",
      "Associated types are faster",
      "Generic params are deprecated"
    ],
    "correct": 0,
    "explanation": "Can impl Foo<i32> and Foo<String> for same type. Associated types define one impl per type.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch19-03-advanced-traits.html"
  },
  {
    "id": "expert-008",
    "category": "unsafe",
    "difficulty": 5,
    "type": "fix_code",
    "code": "fn split_at_mut<T>(slice: &mut [T], mid: usize) -> (&mut [T], &mut [T]) {\n    let len = slice.len();\n    let ptr = slice.as_mut_ptr();\n    \n    unsafe {\n        (\n            std::slice::from_raw_parts_mut(ptr, mid),\n            std::slice::from_raw_parts_mut(ptr.add(mid), len - mid),\n        )\n    }\n}",
    "question": "Is this safe implementation?",
    "options": [
      "Yes - creates two non-overlapping mutable slices, standard pattern",
      "No - two mutable pointers to same data",
      "No - from_raw_parts_mut is always UB",
      "No - need to check mid <= len"
    ],
    "correct": 0,
    "explanation": "This is how std splits slices. Two pointers to different regions, meeting unsafe requirements. Should add bounds check though.",
    "rust_book_link": "https://doc.rust-lang.org/src/core/slice/mod.rs.html#1977"
  },
  {
    "id": "expert-009",
    "category": "macros",
    "difficulty": 5,
    "type": "predict_output",
    "code": "macro_rules! gen_impl {\n    ($($trait:ident),+) => {\n        $(\n            impl $trait for MyType {}\n        )+\n    };\n}\n\nstruct MyType;\ngen_impl!(Clone, Debug, Default);",
    "question": "What does this generate?",
    "options": [
      "Three separate impl blocks for MyType",
      "Single impl block with three traits",
      "Compile error - can't repeat impl",
      "Nothing - macros can't generate impls"
    ],
    "correct": 0,
    "explanation": "Repetition $( )+ expands to multiple impl blocks. Useful for generating boilerplate trait implementations.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch19-06-macros.html"
  },
  {
    "id": "expert-010",
    "category": "async_await",
    "difficulty": 5,
    "type": "idiomatic",
    "code": "// Stream vs Iterator",
    "question": "When to use Stream over Iterator?",
    "options": [
      "Stream for async values arriving over time, Iterator for sync",
      "Always use Stream in async code",
      "They're identical",
      "Iterator is deprecated"
    ],
    "correct": 0,
    "explanation": "Stream is async Iterator. Use for values produced asynchronously (network, timers). Iterator for sync sequences.",
    "rust_book_link": "https://rust-lang.github.io/async-book/05_streams/01_chapter.html"
  },
  {
    "id": "expert-011",
    "category": "traits_generics",
    "difficulty": 5,
    "type": "spot_error",
    "code": "fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &'a str \n    where 'b: 'a \n{\n    if x.len() > y.len() { x } else { y }\n}",
    "question": "What does 'b: 'a mean?",
    "options": [
      "'b outlives 'a - y lives at least as long as x",
      "'a outlives 'b",
      "Syntax error",
      "'a and 'b must be equal"
    ],
    "correct": 0,
    "explanation": "Lifetime bound 'b: 'a means 'b outlives 'a. Allows returning &'a even when sourced from y.",
    "rust_book_link": "https://doc.rust-lang.org/reference/trait-bounds.html#lifetime-bounds"
  },
  {
    "id": "expert-012",
    "category": "ownership",
    "difficulty": 5,
    "type": "will_compile",
    "code": "struct SelfRef {\n    value: String,\n    pointer: *const String,\n}\n\nimpl SelfRef {\n    fn new(value: String) -> Self {\n        let mut s = SelfRef {\n            value,\n            pointer: std::ptr::null(),\n        };\n        s.pointer = &s.value;\n        s\n    }\n}",
    "question": "What's the problem?",
    "options": [
      "Returning s moves it, invalidating self-reference - use Pin",
      "Can't have raw pointers in structs",
      "Nothing wrong",
      "value must be Box<String>"
    ],
    "correct": 0,
    "explanation": "Self-referential struct breaks when moved. s.pointer becomes dangling after return. Need Pin<Box<Self>>.",
    "rust_book_link": "https://doc.rust-lang.org/std/pin/index.html"
  },
  {
    "id": "expert-013",
    "category": "smart_pointers",
    "difficulty": 5,
    "type": "idiomatic",
    "code": "use std::sync::Arc;\nuse parking_lot::Mutex;\n\nstruct Data {\n    value: Arc<Mutex<i32>>,\n}",
    "question": "Why parking_lot::Mutex over std::sync::Mutex?",
    "options": [
      "Faster, no poisoning, smaller size - but loses poison detection",
      "Required by Arc",
      "Always better than std",
      "They're identical"
    ],
    "correct": 0,
    "explanation": "parking_lot is often faster and simpler (no poison), but std::sync provides poison detection for panic safety.",
    "rust_book_link": "https://docs.rs/parking_lot/"
  },
  {
    "id": "expert-014",
    "category": "unsafe",
    "difficulty": 5,
    "type": "predict_output",
    "code": "fn main() {\n    let x = vec![1, 2, 3];\n    let ptr = x.as_ptr();\n    drop(x);\n    unsafe {\n        println!(\"{}\", *ptr);\n    }\n}",
    "question": "What happens?",
    "options": [
      "Undefined behavior - use after free, ptr is dangling",
      "Prints 1",
      "Compile error",
      "Runtime panic"
    ],
    "correct": 0,
    "explanation": "drop() deallocates x's memory. Dereferencing ptr accesses freed memory - classic use-after-free UB.",
    "rust_book_link": "https://doc.rust-lang.org/nomicon/aliasing.html"
  },
  {
    "id": "expert-015",
    "category": "traits_generics",
    "difficulty": 5,
    "type": "fix_code",
    "code": "trait Container {\n    fn items(&self) -> &Vec<i32>;\n}",
    "question": "More flexible return type?",
    "options": [
      "Change to &[i32] - works with Vec, arrays, slices",
      "Change to Vec<i32> - owned",
      "Add impl Iterator<Item=i32>",
      "Current is best"
    ],
    "correct": 0,
    "explanation": "Returning &[i32] is more flexible than &Vec. Implementers can return references to any contiguous sequence.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch15-02-deref.html"
  },
  {
    "id": "expert-016",
    "category": "async_await",
    "difficulty": 5,
    "type": "spot_error",
    "code": "async fn process_all(items: Vec<String>) {\n    for item in items {\n        tokio::spawn(async move {\n            // process item\n        });\n    }\n}",
    "question": "What's the issue?",
    "options": [
      "Spawned tasks may outlive function, items processed after return",
      "Can't spawn in loop",
      "async move doesn't work here",
      "Nothing wrong"
    ],
    "correct": 0,
    "explanation": "spawn() doesn't wait for tasks. Function returns immediately, tasks run in background. Use join handles or task groups.",
    "rust_book_link": "https://tokio.rs/tokio/tutorial/spawning"
  },
  {
    "id": "expert-017",
    "category": "macros",
    "difficulty": 5,
    "type": "will_compile",
    "code": "#[cfg(target_os = \"linux\")]\nfn platform_specific() {\n    println!(\"Linux\");\n}\n\n#[cfg(not(target_os = \"linux\"))]\nfn platform_specific() {\n    println!(\"Other\");\n}",
    "question": "What is this pattern?",
    "options": [
      "Conditional compilation - includes different code per platform",
      "Runtime branching",
      "Compile error - duplicate functions",
      "Macro-based polymorphism"
    ],
    "correct": 0,
    "explanation": "#[cfg] is compile-time. Only one function definition included based on target. Zero runtime cost.",
    "rust_book_link": "https://doc.rust-lang.org/reference/conditional-compilation.html"
  },
  {
    "id": "expert-018",
    "category": "lifetimes",
    "difficulty": 5,
    "type": "predict_output",
    "code": "fn foo() -> &'static str {\n    let s = String::from(\"hello\");\n    Box::leak(s.into_boxed_str())\n}",
    "question": "Is Box::leak a valid pattern?",
    "options": [
      "Yes - intentionally leaks memory to get 'static lifetime",
      "No - always a bug",
      "No - Box can't leak",
      "Yes but only in unsafe"
    ],
    "correct": 0,
    "explanation": "Box::leak prevents drop, giving 'static ref. Valid for long-lived data, but creates intentional memory leak.",
    "rust_book_link": "https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak"
  },
  {
    "id": "expert-019",
    "category": "ownership",
    "difficulty": 5,
    "type": "idiomatic",
    "code": "// Zero-cost abstraction",
    "question": "What makes Rust abstractions zero-cost?",
    "options": [
      "Compiler optimizations eliminate overhead at compile time",
      "Runtime garbage collection",
      "Dynamic dispatch is free",
      "All abstractions have cost"
    ],
    "correct": 0,
    "explanation": "Monomorphization, inlining, and other opts mean abstractions compile to same code as hand-written. No runtime cost.",
    "rust_book_link": "https://blog.rust-lang.org/2015/05/11/traits.html"
  },
  {
    "id": "expert-020",
    "category": "smart_pointers",
    "difficulty": 5,
    "type": "fix_code",
    "code": "use std::sync::Arc;\nuse std::thread;\n\nlet data = Arc::new(vec![1, 2, 3]);\n\nlet handle = thread::spawn(|| {\n    println!(\"{:?}\", data);\n});",
    "question": "How to fix closure capture?",
    "options": [
      "Clone Arc before closure: let data = Arc::clone(&data);",
      "Use move keyword only",
      "data doesn't need cloning",
      "Use &data in closure"
    ],
    "correct": 0,
    "explanation": "Need to clone Arc before move closure to give ownership to thread. Arc::clone increments refcount.",
    "rust_book_link": "https://doc.rust-lang.org/book/ch16-03-shared-state.html"
  },
  {
    "id": "expert-021",
    "category": "unsafe",
    "difficulty": 5,
    "type": "spot_error",
    "code": "fn extend_lifetime<'a>(s: &str) -> &'a str {\n    s\n}",
    "question": "Is this safe?",
    "options": [
      "No - caller can create dangling reference by passing short-lived str",
      "Yes - just returns input",
      "Yes - lifetime elision handles it",
      "No - need unsafe block"
    ],
    "correct": 0,
    "explanation": "Allows caller to extend lifetime arbitrarily. Can return reference outliving source. Classic lifetime hole.",
    "rust_book_link": "https://doc.rust-lang.org/nomicon/lifetimes.html"
  },
  {
    "id": "expert-022",
    "category": "traits_generics",
    "difficulty": 5,
    "type": "will_compile",
    "code": "trait Animal {\n    const LEGS: u32;\n}\n\nstruct Dog;\nimpl Animal for Dog {\n    const LEGS: u32 = 4;\n}\n\nfn count_legs<T: Animal>() -> u32 {\n    T::LEGS\n}",
    "question": "What are const trait items useful for?",
    "options": [
      "Compile-time constants associated with types/traits",
      "Runtime configuration",
      "Dynamic dispatch",
      "Only for documentation"
    ],
    "correct": 0,
    "explanation": "Associated consts provide compile-time values tied to types. Useful for sizes, capacities, feature flags.",
    "rust_book_link": "https://doc.rust-lang.org/reference/items/associated-items.html#associated-constants"
  },
  {
    "id": "expert-023",
    "category": "async_await",
    "difficulty": 5,
    "type": "predict_output",
    "code": "use tokio::time::{sleep, Duration};\n\n#[tokio::main]\nasync fn main() {\n    let fut = async {\n        sleep(Duration::from_secs(1)).await;\n        println!(\"Done\");\n    };\n    println!(\"Started\");\n}",
    "question": "What prints?",
    "options": [
      "Only 'Started' - future never awaited",
      "'Started' then 'Done' after 1 sec",
      "'Done' then 'Started'",
      "Compile error"
    ],
    "correct": 0,
    "explanation": "Futures are lazy. Without .await, fut is created but never executed. Only 'Started' prints.",
    "rust_book_link": "https://rust-lang.github.io/async-book/02_execution/01_chapter.html"
  },
  {
    "id": "expert-024",
    "category": "macros",
    "difficulty": 5,
    "type": "idiomatic",
    "code": "// Hygiene in macros",
    "question": "What is macro hygiene?",
    "options": [
      "Prevents name collisions between macro and call site scopes",
      "Memory safety for macros",
      "Type checking for macros",
      "Macro documentation"
    ],
    "correct": 0,
    "explanation": "Hygiene ensures macro-internal variables don't conflict with caller's. Most macros are hygienic by default.",
    "rust_book_link": "https://doc.rust-lang.org/reference/macros-by-example.html#hygiene"
  },
  {
    "id": "expert-025",
    "category": "ownership",
    "difficulty": 5,
    "type": "fix_code",
    "code": "fn returns_closure() -> Box<dyn Fn(i32) -> i32> {\n    let num = 5;\n    Box::new(|x| x + num)\n}",
    "question": "Why does this fail?",
    "options": [
      "Closure captures num by reference, but num dropped - use move",
      "Can't return closures",
      "Box doesn't work with Fn",
      "Nothing wrong"
    ],
    "correct": 0,
    "explanation": "Closure borrows num, but it goes out of scope. Use move || to capture by value: Box::new(move |x| x + num)",
    "error_line": 3,
    "rust_book_link": "https://doc.rust-lang.org/book/ch13-01-closures.html"
  }
]
